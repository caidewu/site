<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>麦桃说</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://koro.fun/"/>
  <updated>2018-02-12T07:49:24.308Z</updated>
  <id>https://koro.fun/</id>
  
  <author>
    <name>蔡德伍</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决在Mac中ssh登录后闲置时间过长而断开连接</title>
    <link href="https://koro.fun/2018/02/12/%E8%A7%A3%E5%86%B3%E5%9C%A8Mac%E4%B8%ADssh%E7%99%BB%E5%BD%95%E5%90%8E%E9%97%B2%E7%BD%AE%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF%E8%80%8C%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/"/>
    <id>https://koro.fun/2018/02/12/解决在Mac中ssh登录后闲置时间过长而断开连接/</id>
    <published>2018-02-12T02:54:38.000Z</published>
    <updated>2018-02-12T07:49:24.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当我们通过Mac终端连接服务器（比如阿里云的EC2），如果长时间不操作，一般服务器就会自动断开连接，这时候只能重新连接，感觉很麻烦。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我发现其实在windows中用xshell通过ssh连接服务器就不会断开连接。</p><p>原理其实很简单，就是每隔一段时间客户端和服务器通信一次，比如发送一个消息，以此来保证服务器和客户端是活动状态，这样就永远不会存在超时断开连接的情况。</p><p>实际上只要修改一下ssh配置可以做到这一点。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>首先要找到本机(注意：是Mac，而不是服务器)的ssh的配置文件，在<code>/etc/ssh/</code>目录下, 可以看到ssh有两个配置文件</p><ul><li>ssh_config: 这是ssh客户端的配置</li><li>sshd_config: 这是ssh服务端的配置，也就是当别的机器来连接本机的，配置ssh的行为</li></ul><p>直接修改ssh_config文件</p><p>将 <code>ServerAliveInterval  0</code> 改为<code>ServerAliveInterval 60</code></p><p>如果没有<code>ServerAliveInterval  0</code></p><p>直接在ssh_config文件的最后加上<code>ServerAliveInterval 60</code></p><p>以下就是我自己的ssh_config文件的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">  SendEnv LANG LC_*</span><br><span class="line">  ServerAliveInterval 60</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;当我们通过Mac终端连接服务器（比如阿里云的EC2），如果长时间不操作，一般服务器就会自动断开连接，这时候只能重新连接，感觉很麻烦。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="shell" scheme="https://koro.fun/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>使用webpack-dev-server时不要配置6000端口</title>
    <link href="https://koro.fun/2017/07/02/%E4%BD%BF%E7%94%A8webpack-dev-server%E6%97%B6%E4%B8%8D%E8%A6%81%E9%85%8D%E7%BD%AE6000%E7%AB%AF%E5%8F%A3/"/>
    <id>https://koro.fun/2017/07/02/使用webpack-dev-server时不要配置6000端口/</id>
    <published>2017-07-02T03:14:58.000Z</published>
    <updated>2017-07-02T05:41:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在搭建一个新项目，然后使用chrome始终无法访问，反复研究配置文件也没发现有什么不对，仔细看chrome的报错</p><blockquote><p>网址为 <a href="http://localhost:6000/" target="_blank" rel="noopener">http://localhost:6000/</a> 的网页可能暂时无法连接，或者它已永久性地移动到了新网址。<br>ERR_UNSAFE_PORT</p></blockquote><p>一开始我以为是6000端口被占用了，</p><p>使用<code>lsof -i:6000</code>并没有发现有应用占用了6000端口，</p><p>仔细再看报错信息，其实重点是<strong><code>ERR_UNSAFE_PORT</code></strong>,</p><p>难道是浏览器禁用了6000端口？</p><p>于是修改了一下webpack-dev-server指定的端口为6001，可以正常访问了</p><a id="more"></a><p>那么问题来了，chrome到底禁用了哪些端口,google了一下有如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">1,    &#x2F;&#x2F; tcpmux</span><br><span class="line">  7,    &#x2F;&#x2F; echo</span><br><span class="line">  9,    &#x2F;&#x2F; discard</span><br><span class="line">  11,   &#x2F;&#x2F; systat</span><br><span class="line">  13,   &#x2F;&#x2F; daytime</span><br><span class="line">  15,   &#x2F;&#x2F; netstat</span><br><span class="line">  17,   &#x2F;&#x2F; qotd</span><br><span class="line">  19,   &#x2F;&#x2F; chargen</span><br><span class="line">  20,   &#x2F;&#x2F; ftp data</span><br><span class="line">  21,   &#x2F;&#x2F; ftp access</span><br><span class="line">  22,   &#x2F;&#x2F; ssh</span><br><span class="line">  23,   &#x2F;&#x2F; telnet</span><br><span class="line">  25,   &#x2F;&#x2F; smtp</span><br><span class="line">  37,   &#x2F;&#x2F; time</span><br><span class="line">  42,   &#x2F;&#x2F; name</span><br><span class="line">  43,   &#x2F;&#x2F; nicname</span><br><span class="line">  53,   &#x2F;&#x2F; domain</span><br><span class="line">  77,   &#x2F;&#x2F; priv-rjs</span><br><span class="line">  79,   &#x2F;&#x2F; finger</span><br><span class="line">  87,   &#x2F;&#x2F; ttylink</span><br><span class="line">  95,   &#x2F;&#x2F; supdup</span><br><span class="line">  101,  &#x2F;&#x2F; hostriame</span><br><span class="line">  102,  &#x2F;&#x2F; iso-tsap</span><br><span class="line">  103,  &#x2F;&#x2F; gppitnp</span><br><span class="line">  104,  &#x2F;&#x2F; acr-nema</span><br><span class="line">  109,  &#x2F;&#x2F; pop2</span><br><span class="line">  110,  &#x2F;&#x2F; pop3</span><br><span class="line">  111,  &#x2F;&#x2F; sunrpc</span><br><span class="line">  113,  &#x2F;&#x2F; auth</span><br><span class="line">  115,  &#x2F;&#x2F; sftp</span><br><span class="line">  117,  &#x2F;&#x2F; uucp-path</span><br><span class="line">  119,  &#x2F;&#x2F; nntp</span><br><span class="line">  123,  &#x2F;&#x2F; NTP</span><br><span class="line">  135,  &#x2F;&#x2F; loc-srv &#x2F;epmap</span><br><span class="line">  139,  &#x2F;&#x2F; netbios</span><br><span class="line">  143,  &#x2F;&#x2F; imap2</span><br><span class="line">  179,  &#x2F;&#x2F; BGP</span><br><span class="line">  389,  &#x2F;&#x2F; ldap</span><br><span class="line">  465,  &#x2F;&#x2F; smtp+ssl</span><br><span class="line">  512,  &#x2F;&#x2F; print &#x2F; exec</span><br><span class="line">  513,  &#x2F;&#x2F; login</span><br><span class="line">  514,  &#x2F;&#x2F; shell</span><br><span class="line">  515,  &#x2F;&#x2F; printer</span><br><span class="line">  526,  &#x2F;&#x2F; tempo</span><br><span class="line">  530,  &#x2F;&#x2F; courier</span><br><span class="line">  531,  &#x2F;&#x2F; chat</span><br><span class="line">  532,  &#x2F;&#x2F; netnews</span><br><span class="line">  540,  &#x2F;&#x2F; uucp</span><br><span class="line">  556,  &#x2F;&#x2F; remotefs</span><br><span class="line">  563,  &#x2F;&#x2F; nntp+ssl</span><br><span class="line">  587,  &#x2F;&#x2F; stmp?</span><br><span class="line">  601,  &#x2F;&#x2F; ??</span><br><span class="line">  636,  &#x2F;&#x2F; ldap+ssl</span><br><span class="line">  993,  &#x2F;&#x2F; ldap+ssl</span><br><span class="line">  995,  &#x2F;&#x2F; pop3+ssl</span><br><span class="line">  2049, &#x2F;&#x2F; nfs</span><br><span class="line">  3659, &#x2F;&#x2F; apple-sasl &#x2F; PasswordServer</span><br><span class="line">  4045, &#x2F;&#x2F; lockd</span><br><span class="line">  6000, &#x2F;&#x2F; X11</span><br><span class="line">  6665, &#x2F;&#x2F; Alternate IRC [Apple addition]</span><br><span class="line">  6666, &#x2F;&#x2F; Alternate IRC [Apple addition]</span><br><span class="line">  6667, &#x2F;&#x2F; Standard IRC [Apple addition]</span><br><span class="line">  6668, &#x2F;&#x2F; Alternate IRC [Apple addition]</span><br><span class="line">  6669, &#x2F;&#x2F; Alternate IRC [Apple addition]</span><br></pre></td></tr></table></figure><p>通常我们在本地搭建开发环境时通常使用4位数的整数作为端口，比如3000，8000，8080…，所以上面这些被禁用端口就是6000被误用的可能性比较大，记住6000是x11用的端口以后避开就行了</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://superuser.com/questions/188058/which-ports-are-considered-unsafe-on-chrome" target="_blank" rel="noopener">https://superuser.com/questions/188058/which-ports-are-considered-unsafe-on-chrome</a></li><li><a href="https://www.zhihu.com/question/27939248?sort=created" target="_blank" rel="noopener">X11 是什么？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在搭建一个新项目，然后使用chrome始终无法访问，反复研究配置文件也没发现有什么不对，仔细看chrome的报错&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网址为 &lt;a href=&quot;http://localhost:6000/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://localhost:6000/&lt;/a&gt; 的网页可能暂时无法连接，或者它已永久性地移动到了新网址。&lt;br&gt;ERR_UNSAFE_PORT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始我以为是6000端口被占用了，&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;lsof -i:6000&lt;/code&gt;并没有发现有应用占用了6000端口，&lt;/p&gt;
&lt;p&gt;仔细再看报错信息，其实重点是&lt;strong&gt;&lt;code&gt;ERR_UNSAFE_PORT&lt;/code&gt;&lt;/strong&gt;,&lt;/p&gt;
&lt;p&gt;难道是浏览器禁用了6000端口？&lt;/p&gt;
&lt;p&gt;于是修改了一下webpack-dev-server指定的端口为6001，可以正常访问了&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack热更新延迟问题</title>
    <link href="https://koro.fun/2017/06/24/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://koro.fun/2017/06/24/webpack热更新延迟问题/</id>
    <published>2017-06-24T10:56:49.000Z</published>
    <updated>2018-11-14T14:04:28.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提一"><a href="#前提一" class="headerlink" title="前提一"></a>前提一</h3><p>如果后端服务是通过session来控制用户登录态的，在客户端就是用过cookie来保存sessionid，而在前后端分离的情况下，cookie就需要保存在根域才可以保证客户端可以读到cookie</p><a id="more"></a><h3 id="前提二"><a href="#前提二" class="headerlink" title="前提二"></a>前提二</h3><p>如今使用webpack来构建前端项目，特别是react项目，必然是想要用webpack的热更新功能，那么就需要使用<code>webpack-dev-server</code>，但是webpack-dev-server怎么去配置域名？因为前提一的SessionId是要存在根域中</p><h3 id="前提三"><a href="#前提三" class="headerlink" title="前提三"></a>前提三</h3><p>为了解决 前提一 + 前提二 的问题，那么我决定使用nginx来给webpack-dev-server做反向代理</p><p>配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  admin.xinlebao.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:5000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标题所诉的问题来了"><a href="#标题所诉的问题来了" class="headerlink" title="标题所诉的问题来了"></a>标题所诉的问题来了</h3><p>这样配置后确实可以拿到sessionId了，但是感觉有点不对，webpack热更新似乎是失效了</p><p>但是仔细观察，其实并没有失效，只是延迟了</p><p>比如，第一次修改的代码，页面接收到了hot-update.js，但是页面并没有更新，此时，我再次修改代码，页面同样会接收到hot-update.js，而此时页面内容更新了，但更新是第一次修改内容</p><p>最终的原因是nginx默认开启的buffer机制缓存了服务器推送的片段信息，缓存达到一定的量才会返回响应内容。只要关闭proxy_buffering即可。</p><p>如下：</p><p><code>`</code></p><p>server {<br>    listen       80;<br>    server_name  admin.xinlebao.com;<br>    location / {<br>        proxy_pass <a href="http://loc" target="_blank" rel="noopener">http://loc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前提一&quot;&gt;&lt;a href=&quot;#前提一&quot; class=&quot;headerlink&quot; title=&quot;前提一&quot;&gt;&lt;/a&gt;前提一&lt;/h3&gt;&lt;p&gt;如果后端服务是通过session来控制用户登录态的，在客户端就是用过cookie来保存sessionid，而在前后端分离的情况下，cookie就需要保存在根域才可以保证客户端可以读到cookie&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于NPM中依赖库的版本</title>
    <link href="https://koro.fun/2017/05/04/%E5%85%B3%E4%BA%8ENPM%E4%B8%AD%E4%BE%9D%E8%B5%96%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC/"/>
    <id>https://koro.fun/2017/05/04/关于NPM中依赖库的版本/</id>
    <published>2017-05-04T08:26:33.000Z</published>
    <updated>2017-05-04T08:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大版本限定"><a href="#大版本限定" class="headerlink" title="大版本限定^"></a>大版本限定<code>^</code></h2><p>如：”angular”: “^1.3.2”,</p><ul><li>1.3.2 升级到1.3.3 会自动升级</li><li>1.3.2 升级到1.4.x 会自动升级 </li><li>1.x.x 升级到2.x.x则不会自动升级 </li></ul><h2 id="小版本限定"><a href="#小版本限定" class="headerlink" title="小版本限定 ~"></a>小版本限定 <code>~</code></h2><p>如:”angular”: “~1.3.2”</p><ul><li>1.3.2 升级到1.3.3 会自动升级</li><li>1.3.2 升级到1.4.x 则不会自动升级 </li><li>1.x.x 升级到2.x.x  更不会自动升级</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大版本限定&quot;&gt;&lt;a href=&quot;#大版本限定&quot; class=&quot;headerlink&quot; title=&quot;大版本限定^&quot;&gt;&lt;/a&gt;大版本限定&lt;code&gt;^&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;如：”angular”: “^1.3.2”,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.3.2 升
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我也来说说Event Loop</title>
    <link href="https://koro.fun/2017/03/10/%E6%88%91%E4%B9%9F%E6%9D%A5%E8%AF%B4%E8%AF%B4Event-Loop/"/>
    <id>https://koro.fun/2017/03/10/我也来说说Event-Loop/</id>
    <published>2017-03-10T14:16:20.000Z</published>
    <updated>2017-03-10T14:16:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Untitled</title>
    <link href="https://koro.fun/2017/03/10/Untitled/"/>
    <id>https://koro.fun/2017/03/10/Untitled/</id>
    <published>2017-03-10T14:03:52.000Z</published>
    <updated>2017-03-10T14:03:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个模块内部为什么有exports还需要有module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var module &#x3D; &#123;&#125;;</span><br><span class="line">module.exports &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(function (module, exports, require) &#123;</span><br><span class="line">    var Dialog &#x3D; &#123;width: 300, height: 400&#125;;</span><br><span class="line">    exports &#x3D; Dialog; &#x2F;&#x2F; 这里exports完全被替换了，也就和module没有关系了</span><br><span class="line">&#125;)(module, module.exports);</span><br><span class="line"></span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个模块内部为什么有exports还需要有module&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈我对call、apply的理解</title>
    <link href="https://koro.fun/2017/03/10/%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9call%E3%80%81apply%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://koro.fun/2017/03/10/谈谈我对call、apply的理解/</id>
    <published>2017-03-09T17:10:49.000Z</published>
    <updated>2017-03-10T19:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>call在js面试中的地位不亚与prototype，但是可能连面试官都不一定真正搞懂call到底做了什么，不着急，先从标志答案说起</p></blockquote><h2 id="call是用来做什么的"><a href="#call是用来做什么的" class="headerlink" title="call是用来做什么的"></a>call是用来做什么的</h2><p>call是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call(thisArg, arg1, arg2, arg3)</span><br></pre></td></tr></table></figure><p>所以call是一个方法（函数）,第一个参数是指定调用函数的上下文(this),后面的参数列表，就是调用函数需要传入的参数</p><p>返回值是执行函数的返回值</p><p>用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var foo &#x3D; &#123;</span><br><span class="line">a: &#39;1&#39;,</span><br><span class="line">b: &#39;2&#39;,</span><br><span class="line">test: function(args1) &#123;</span><br><span class="line">console.log(args1);</span><br><span class="line">return &#123;ta: this.a, tb: this.b&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.test(&#39;normal invoked&#39;);</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;a: &#39;111&#39;, b: &#39;222&#39;&#125;;</span><br><span class="line">foo.test.call(obj,&#39;invoked by obj&#39;);</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出 normal invoked</span><br><span class="line">返回值是 &#123;ta: &#39;1&#39;, tb: &#39;2&#39;&#125;</span><br><span class="line"></span><br><span class="line">输出 invoked by obj</span><br><span class="line">返回值是 &#123;ta: &#39;111&#39;, tb: &#39;222&#39;&#125;</span><br></pre></td></tr></table></figure><p>所以说，call就是用来改变运行函数执行的上下文环境，也就是this，这个就算是标准答案，我面试时也是这么说的，那么面试官一定会追问下面这个问题</p><h2 id="call与apply有什么区别"><a href="#call与apply有什么区别" class="headerlink" title="call与apply有什么区别"></a>call与apply有什么区别</h2><p>基本用过call和apply的同学基本知道call是接收的参数列表，apply接收的是数组</p><p>而看过文档就知道，apply接收是类数组对象（array-like object），什么是类数组对象，举个例子 <code>arguments</code></p><p>那为什么可以接收数组，因为数组不仅仅是类数组对象，同时他还是数组</p><p>这里举一个apply的实用案例：获取数组中的最大(小)值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max.apply(null, [12,34,23423,235,32]);</span><br></pre></td></tr></table></figure><p>返回值是：23423</p><h2 id="Function-call"><a href="#Function-call" class="headerlink" title="Function.call"></a>Function.call</h2><blockquote><p>你知道<code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].map(Function.call, Number);</code>的结果是什么吗？</p></blockquote><p>终于进入正题！</p><p>首先map接收两个参数，一个是回调函数<code>function(value, index, array) {}</code>, <br><br>第二参数一般不常用，是指定回调函数的上下文环境，也就是this</p><p>先来看下map的简单实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.map &#x3D; function(fn, ctx) &#123;</span><br><span class="line">var result &#x3D; new Array(this.length);</span><br><span class="line">for (var i &#x3D; 0; i &lt; this.length; i++) &#123;</span><br><span class="line">result[i] &#x3D; fn.call(ctx, this[i], i, this);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整版的map polyfill参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Polyfill" target="_blank" rel="noopener">这里</a></p><p>因为map内部实现也是用了call方法</p><p>所以<code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].map(Function.call, Number);</code>可以转换成如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> Function.call.call(Number, &quot;a&quot;,   0, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]),</span><br><span class="line">Function.call.call(Number, &quot;b&quot;,  1, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]),</span><br><span class="line">Function.call.call(Number, &quot;c&quot;, 2, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>简化之后会变成如下，这里会让很多人疑惑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">Number.call(&quot;a&quot;, 0, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]), </span><br><span class="line">Number.call(&quot;b&quot;, 1, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]),    </span><br><span class="line">Number.call(&quot;c&quot;, 2, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])    </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这时候就要看call的内部实现是怎样的了，根据规范的定义和，我猜测call的内部应该是类似如下的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function F() &#123;</span><br><span class="line">    let args &#x3D; arguments.length &#x3D;&#x3D;&#x3D;1 ? [arguments[0]] : Array.apply(null, arguments);</span><br><span class="line">    let ctx &#x3D; args.shift();</span><br><span class="line"></span><br><span class="line">    if (this &#x3D;&#x3D;&#x3D; F) &#123;</span><br><span class="line">        let that &#x3D; args.shift();</span><br><span class="line">        return ctx.apply(that, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return this.apply(ctx, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function.prototype.fakeCall &#x3D; F;</span><br></pre></td></tr></table></figure><p>再来个简化版，只看执行逻辑，忽略掉参数的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function F(thisArg, arg1, arg2, arg3) &#123;</span><br><span class="line">if ( this &#x3D;&#x3D;&#x3D; F ) &#123;</span><br><span class="line">return thisArg(arg2, arg3);  &#x2F;&#x2F; context: arg1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return this(arg1, arg2, arg3); &#x2F;&#x2F; context: thisArg</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说call的内部是把this作为一个函数执行了，如果这时候你已经不知道this是什么了，请回去看第一个例子，一个函数中的this默认是指向它外层的对象，</p><p>正常情况使用call，如 <code>Foo.test.call(obj)</code>,call内部的this就是test，执行this，就是执行test</p><p>再比如<code>[].slice.call(arguments)</code>,call内部this就是slice，执行this，就是执行slice，而slice内部的this就是arguments</p><p>而<code>Function.call.call(Number, &quot;a&quot;,   0, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</code>, call内部的this指向call，那么call内部会进入if的条件中，执行函数变成了<code>Number.call( &quot;a&quot;,   0, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</code></p><p>至此应该就可以理解上面的那个简化是怎么来的了</p><p>然后再简化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">Number(0, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]),    &#x2F;&#x2F; this &#x3D; &#39;a&#39;</span><br><span class="line">Number(1, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]),    &#x2F;&#x2F; this &#x3D; &#39;b&#39;</span><br><span class="line">Number(2, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])     &#x2F;&#x2F; this &#x3D; &#39;c&#39;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后</p><p><code>[0, 1, 2]</code></p><h2 id="fn-call-call-call-call-call-call"><a href="#fn-call-call-call-call-call-call" class="headerlink" title="fn.call.call.call.call.call.call()"></a>fn.call.call.call.call.call.call()</h2><p>有人看到call.call就这么复杂，那如果是很多个call，意味着什么？</p><p>意味着还是fn.call.call()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function.call &#x3D;&#x3D;&#x3D; Function.call.call        &#x2F;&#x2F; true</span><br><span class="line">Function.call &#x3D;&#x3D;&#x3D; Function.call.call.call   &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>因为Function.prototype.call，这是原型上的方法，点多少个都是它自己，而call只认调用他的那个对象到底是什么，如果是普通对象，那说明只有一个call，如果是call，那就按照call.call的方式去处理</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://blog.sina.com.cn/s/blog_70a3539f0101fref.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_70a3539f0101fref.html</a></li><li><a href="https://zhidao.baidu.com/question/1795031515293789747.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1795031515293789747.html</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments</a></li><li><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.call" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.call</a></li><li><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist</a></li></ul>]]></content>
    
    <summary type="html">
    
      你知道[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].map(Function.call, Number)的结果是什么吗？
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>display visibility opacity隐藏元素的区别</title>
    <link href="https://koro.fun/2017/03/05/display%20visibility%20opacity%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://koro.fun/2017/03/05/display visibility opacity隐藏元素的区别/</id>
    <published>2017-03-05T12:12:04.000Z</published>
    <updated>2017-03-05T15:19:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们都知道隐藏元素通常使用的方法是<code>display: none</code>，不过很明显这不是唯一的一种方式，CSS2的<code>visibility: hidden</code>和CSS3的<code>opacity: 0</code>均可以隐藏元素，那么他们的区别是什么</p></blockquote><pre><code>css         | 是否占据空间 | 是否可以触发事件 | 是否受tab控制</code></pre><p>—————– | —–| —- | ——–<br>display: none     | No   | No   | No<br>visibility: hidden| Yes  | No   | No<br>opacity: 0        | Yes  | Yes  | Yes</p><a id="more"></a><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><ol><li><code>opacity: 0</code>其实只是透明度是0，所以看不见，元素本身还在那，他的事件，占据的空间，默认行为都还在</li><li><code>display: none</code> 和 <code>visibility: hidden</code>都是隐藏元素，所以元素的默认行为，绑定的事件均失效</li><li><code>visibility: hidden</code>会占据空间，而且它的子元素如果被设置为<code>visibility: visible</code>，那么这个子元素会单独显示出来</li><li>只有opacity的隐藏才会实现transition的过渡动画</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://stackoverflow.com/questions/272360/does-opacity0-have-exactly-the-same-effect-as-visibilityhidden" target="_blank" rel="noopener">http://stackoverflow.com/questions/272360/does-opacity0-have-exactly-the-same-effect-as-visibilityhidden</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们都知道隐藏元素通常使用的方法是&lt;code&gt;display: none&lt;/code&gt;，不过很明显这不是唯一的一种方式，CSS2的&lt;code&gt;visibility: hidden&lt;/code&gt;和CSS3的&lt;code&gt;opacity: 0&lt;/code&gt;均可以隐藏元素，那么他们的区别是什么&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;css         | 是否占据空间 | 是否可以触发事件 | 是否受tab控制
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;—————– | —–| —- | ——–&lt;br&gt;display: none     | No   | No   | No&lt;br&gt;visibility: hidden| Yes  | No   | No&lt;br&gt;opacity: 0        | Yes  | Yes  | Yes&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://koro.fun/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>DOM中的事件流</title>
    <link href="https://koro.fun/2017/02/24/DOM%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <id>https://koro.fun/2017/02/24/DOM中的事件流/</id>
    <published>2017-02-24T15:26:54.000Z</published>
    <updated>2017-02-24T16:30:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天在写事件监听器时，突然想起addEventListener方法是有一个非必填的参数，用来定义事件的执行阶段， 捕获还是冒泡，true是捕获还是false是捕获，记忆有些模糊了…</p></blockquote><h2 id="先看一段代码"><a href="#先看一段代码" class="headerlink" title="先看一段代码"></a>先看一段代码</h2><p>HTML结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;content&quot;&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;btn&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>JS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#39;click&#39;, function(e) &#123;</span><br><span class="line">    alert(&#39;document&#39;);</span><br><span class="line">&#125;,true);</span><br><span class="line">document.querySelector(&#39;#wrapper&#39;).addEventListener(&#39;click&#39;, function(e) &#123;</span><br><span class="line">    alert(&#39;wrapper&#39;);</span><br><span class="line">&#125;,false);</span><br><span class="line"></span><br><span class="line">document.querySelector(&#39;#content&#39;).addEventListener(&#39;click&#39;, function(e) &#123;</span><br><span class="line">    alert(&#39;content&#39;);</span><br><span class="line">&#125;,true);</span><br><span class="line"></span><br><span class="line">document.querySelector(&#39;#btn&#39;).addEventListener(&#39;click&#39;, function(e) &#123;</span><br><span class="line">    alert(&#39;btn&#39;);</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure><p><strong>提问：</strong> 那么，点击按钮后，alert的顺序是怎样的？</p><a id="more"></a><p>如果你的答案是 document content btn wrapper，那么下面的废话可以不用看了</p><h2 id="先捕获，后冒泡"><a href="#先捕获，后冒泡" class="headerlink" title="先捕获，后冒泡"></a>先捕获，后冒泡</h2><p>首先，要知道addEventListener方法的第二个参数</p><ul><li>设置true，是定义该事件在捕获阶段执行，</li><li>设置false，或者不设置，事件在冒泡阶段执行</li></ul><h3 id="事件捕获（Capture-Phase）"><a href="#事件捕获（Capture-Phase）" class="headerlink" title="事件捕获（Capture Phase）"></a>事件捕获（Capture Phase）</h3><p>事件捕获是最早是Netscape对事件流的实现：当事件被触发的时候，从根节点一个个去检查是否有绑定事件，如果就触发事件，没有就下一个节点，直到点击的那个元素的父元素为止</p><p>当事件捕获结束后，再执行触发事件的元素的事件</p><h3 id="事件冒泡（Bubbling-Phase）"><a href="#事件冒泡（Bubbling-Phase）" class="headerlink" title="事件冒泡（Bubbling Phase）"></a>事件冒泡（Bubbling Phase）</h3><p>事件冒泡最早是IE对事件流的实现：当事件被触发后，当前元素上绑定的事件立即执行</p><p>然后事件开始冒泡，先检查这个元素的父元素，如有绑定事件就触发事件，没有就往上走，直至文档的根节点</p><h3 id="W3C一统天下"><a href="#W3C一统天下" class="headerlink" title="W3C一统天下"></a>W3C一统天下</h3><p>W3C在规范中包含这两种事件机制，用一句话说明: <strong>先捕获，后冒泡</strong></p><p>最后引用规范中的这张图来说明</p><p><img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt=""></p><h2 id="答案解释"><a href="#答案解释" class="headerlink" title="答案解释"></a>答案解释</h2><p>当按钮按下后，</p><p>第一阶段：<br><br>先捕获，那么有两个事件是设置在捕获阶段执行的，而且捕获是有外层到里的顺序，所以，document先执行，然后到content，捕获阶段结束</p><p>第二阶段：<br><br>触发事件的元素btn执行</p><p>第三阶段：<br><br>开始冒泡，离btn最近的一个父节点开始往外走，然后wrapper上有绑定事件，所以wrapper触发，继续往外走，没有事件了，结束</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow" target="_blank" rel="noopener">https://www.w3.org/TR/DOM-Level-3-Events/#event-flow</a></li><li><a href="http://javascript.ruanyifeng.com/dom/event.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/dom/event.html</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#Multiple_identical_event_listeners" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#Multiple_identical_event_listeners</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天在写事件监听器时，突然想起addEventListener方法是有一个非必填的参数，用来定义事件的执行阶段， 捕获还是冒泡，true是捕获还是false是捕获，记忆有些模糊了…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;先看一段代码&quot;&gt;&lt;a href=&quot;#先看一段代码&quot; class=&quot;headerlink&quot; title=&quot;先看一段代码&quot;&gt;&lt;/a&gt;先看一段代码&lt;/h2&gt;&lt;p&gt;HTML结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div id&amp;#x3D;&amp;quot;wrapper&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;div id&amp;#x3D;&amp;quot;content&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;lt;button id&amp;#x3D;&amp;quot;btn&amp;quot;&amp;gt;&amp;lt;&amp;#x2F;button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;&amp;#x2F;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;#x2F;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JS代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;document.addEventListener(&amp;#39;click&amp;#39;, function(e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&amp;#39;document&amp;#39;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,true);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;document.querySelector(&amp;#39;#wrapper&amp;#39;).addEventListener(&amp;#39;click&amp;#39;, function(e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&amp;#39;wrapper&amp;#39;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;document.querySelector(&amp;#39;#content&amp;#39;).addEventListener(&amp;#39;click&amp;#39;, function(e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&amp;#39;content&amp;#39;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,true);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;document.querySelector(&amp;#39;#btn&amp;#39;).addEventListener(&amp;#39;click&amp;#39;, function(e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&amp;#39;btn&amp;#39;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,false);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提问：&lt;/strong&gt; 那么，点击按钮后，alert的顺序是怎样的？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jQuery的无冲突处理</title>
    <link href="https://koro.fun/2017/01/19/jQuery%E6%97%A0%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/"/>
    <id>https://koro.fun/2017/01/19/jQuery无冲突处理/</id>
    <published>2017-01-19T07:53:39.000Z</published>
    <updated>2017-01-19T09:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>noConflict这个东西在prototype，mootools这些老古董基本都被淘汰的情况下，能用上的几率基本不大了，本身也是非常简单的东西，说白了就是别名替换。之所以在2017年还谈论这个东西是因为看到书上对这个东西的解释，完全是简单问题复杂化，把我看晕了，所以我看看自己想以最简单的方法把这个东西说清楚</p></blockquote><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当你想在项目里加入一个库，这里拿Zepto和jQuery来举例，</p><p>如果项目原本没有使用过<code>window.$</code>，那么一切正常</p><p>但是如果项目是非常老的项目，你只知道引入了Zepto后，页面有些功能不正常了，当你去掉Zepto后就好了，然后你在console中打印<code>$</code>,发现<code>$</code>被使用了，具体它是个什么库你也不太清楚，如果想用上Zepto怎么办？</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>显然，我需要在加载Zepto之前把<code>window.$</code>先保存起来，比如保存到变量<code>_$</code>中，然后加载Zepto后，<code>window.$</code>已经被赋值为Zepto了，这时重新给<code>window.$</code>赋上<code>_$</code>，然后用Zepto的时候，全局上就只能用别的名字，或者是把<code>$</code>写在闭包里，看下代码是怎样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.$ &#x3D; _$; &#x2F;&#x2F;确保_$在全局中并没有用到</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;zepto&#x2F;1.2.0&#x2F;zepto.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.$ &#x3D; _$;</span><br><span class="line">  </span><br><span class="line">  (function($) &#123;</span><br><span class="line">  $(&#39;xxx&#39;); &#x2F;&#x2F; 在闭包里可以正常用$来表示Zepto </span><br><span class="line">  &#125;)(Zepto)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>那么实际上这就是无冲突处理</p><h2 id="jQuery的做法"><a href="#jQuery的做法" class="headerlink" title="jQuery的做法"></a>jQuery的做法</h2><p>因为Zepto出来的是为移动端服务，追求的是精简，肯定不希望你加两个库做一件事，所以Zepto库里并没有集成无冲突的处理</p><p>但jQuery不一样，jQuery那个年代，各种库都喜欢用<code>$</code>,所以jQuery在加载时都会先把<code>window.$</code>和<code>window.jQuery</code>存起来，然后在给<code>window.$</code>和<code>window.jQuery</code>赋上当前加载版本的jQuery，如果<code>window.$</code>在加载前已经被别的库使用了，那么jQuery提供了一个noConflict的方法，调用该方法即可把<code>window.$</code>还原回原来的</p><p>看看代码是怎么用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;2.2.4&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var jq &#x3D; $.noConflict(); &#x2F;&#x2F; 使用jq表示jQuery，释放$</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">  (function($) &#123;</span><br><span class="line">    $(&#39;xxx&#39;);  &#x2F;&#x2F; 在闭包里可以正常用$来表示jQuery</span><br><span class="line">  &#125;)($.noConflict());</span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>以上示例仅替换了<code>window.$</code></p><p>如果是想同时用两个版本的jQuery，比如先引入了1.x，然后有些地方想用2.x,那么在调用<code>$.noConflict(true)</code>即可同时替换<code>window.$</code>和<code>window.jQuery</code></p><h3 id="看看jQuery源码"><a href="#看看jQuery源码" class="headerlink" title="看看jQuery源码"></a>看看jQuery源码</h3><p>global.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Map over jQuery in case of overwrite</span><br><span class="line">_jQuery &#x3D; window.jQuery,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Map over the $ in case of overwrite</span><br><span class="line">_$ &#x3D; window.$;</span><br><span class="line"></span><br><span class="line">jQuery.noConflict &#x3D; function( deep ) &#123;</span><br><span class="line">if ( window.$ &#x3D;&#x3D;&#x3D; jQuery ) &#123;</span><br><span class="line">window.$ &#x3D; _$;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ( deep &amp;&amp; window.jQuery &#x3D;&#x3D;&#x3D; jQuery ) &#123;</span><br><span class="line">window.jQuery &#x3D; _jQuery;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return jQuery;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Expose jQuery and $ identifiers, even in AMD</span><br><span class="line">&#x2F;&#x2F; (#7102#comment:10, https:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery&#x2F;pull&#x2F;557)</span><br><span class="line">&#x2F;&#x2F; and CommonJS for browser emulators (#13566)</span><br><span class="line">if ( !noGlobal ) &#123;</span><br><span class="line">window.jQuery &#x3D; window.$ &#x3D; jQuery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;noConflict这个东西在prototype，mootools这些老古董基本都被淘汰的情况下，能用上的几率基本不大了，本身也是非常简单的东西，说白了就是别名替换。之所以在2017年还谈论这个东西是因为看到书上对这个东西的解释，完全是简单问题复杂化，把我看晕了，所以我看看自己想以最简单的方法把这个东西说清楚&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>再来说Javascript中的原型</title>
    <link href="https://koro.fun/2016/12/22/%E5%86%8D%E6%9D%A5%E7%9C%8BJavascript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/"/>
    <id>https://koro.fun/2016/12/22/再来看Javascript中的原型/</id>
    <published>2016-12-22T14:55:33.000Z</published>
    <updated>2017-01-06T18:21:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="toString是从哪来的"><a href="#toString是从哪来的" class="headerlink" title="toString是从哪来的"></a>toString是从哪来的</h2><p>先来看一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">console.log(obj.toString()); &#x2F;&#x2F; 结果是：&quot;[object Object]&quot;</span><br></pre></td></tr></table></figure><p>这段代码很简单，一个对象调用了toString方法，但是如果我问你为什么可以调toString方法？toString是从哪来的？</p><p>对于大多学过几天js的人知道，因为obj是继承了Object对象，而toString是Object对象的方法，所以obj可以调toString</p><p>那么很明显，这个回答是正确的错误答案，因为关键字没有说到：<strong>原型</strong></p><a id="more"></a><h2 id="原型是什么？"><a href="#原型是什么？" class="headerlink" title="原型是什么？"></a>原型是什么？</h2><p>首先，原型是一个<strong>普通</strong>的对象。</p><p>为什么说是普通，说明一定有不普通的对象，比如function类型的对象，它就属于不太普通的对象，这个后面说</p><p>在js的世界里，一个普通对象是怎么样</p><ol><li>对象上可以定义方法或属性</li><li>对象一定有一个原型</li><li>对象的原型上的方法和属性，对象本身可以通过<code>.</code>语法获取，就像调用自己的方法和属性一样</li><li>对象的原型是指向其构造函数的prototye属性的指针（引用）</li><li>对象本身的方法或属性会覆盖掉原型上的方法或属性</li></ol><p>一个对象一定有一个原型，而原型又是一个对象，那么原型上就会有原型，这个原型依旧是对象，而这个对象依旧有原型，这样不停往上追溯，直到js的根对象Object.prototype，这个就叫<strong>原型链</strong></p><p>实际上每个对象都有一个存放原型的内部属性 <code>[[prototype]]</code>（实际上看不到，ecma的标准里是这么描述的）, 而在浏览器环境中，提供了一个叫<code>__proto__</code>的属性去访问它，下面就通过<code>__proto__</code>去看看原型链是是怎么链起来的</p><p>先来看一个空对象的原型是怎样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;; &#x2F;&#x2F; 一个空对象，等同于 new Object()</span><br><span class="line"></span><br><span class="line">obj.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p><code>obj.__proto__</code>是obj对象原型，Object是obj对象的构造函数，<br>对象的原型是指向其构造函数的prototye属性的指针，所以结果是true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__.__proto__ &#x3D;&#x3D;&#x3D; null;&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p><code>Object.prototype</code>是最基本的原型，但是它仍然是个对象，所以，它还是有原型的，它的原型一个空对象null，js就是这么定义的,这里不必深究</p><p>上面这个例子因为构造函数就是Object，所以直接就到Object.prototype,没有表现出原型链的样子，下面进入正题</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>通常我们使用的对象并不是使用Object这个构造函数生成的，而是我们自己定义的构造函数，构造函数其实就是函数，而函数其实也是对象，就是前面说的那个不太普通的对象。</p><p>函数对象上拥有一个特殊的属性prototype，其实前面已经有写到（Object.prototype），它就是用来定义存放原型的地方</p><p>js中，因为没有类的概念，所以是构造函数承担类的功能，去定义对象的属性和方法，去实现继承，下面的代码是三个构造函数继承的关系<br><br>Tips继承了Dialog，<br><br>Dialog继承了Modal，<br><br>Modal并没有说明继承了什么，实际上就是继承了Object，通过这种具有继承关系的构造函数，我们可以清晰的看出原型链的形成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Modal 是弹窗，有宽，高和内容</span><br><span class="line"> * Dialog  是对话框， 有宽高，内容 还有一个按钮</span><br><span class="line"> * Tips   是一个提示对话框， 有宽高，内容， 按钮，还有一个标题栏</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">function Modal(height, width, content) &#123;</span><br><span class="line">    this.height &#x3D; height;</span><br><span class="line">    this.width &#x3D; width;</span><br><span class="line">    this.content &#x3D; content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Modal.prototype.open &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;width:&#39; + this.width + &#39; ,height:&#39; + this.height + &#39; ,content:&#39; + this.content);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Dialog(height, width, content, button) &#123;</span><br><span class="line">    Modal.apply(this, arguments);</span><br><span class="line">    this.button &#x3D; button;</span><br><span class="line">&#125;</span><br><span class="line">Dialog.prototype &#x3D; Object.create(Modal.prototype);</span><br><span class="line">Dialog.prototype.constructor &#x3D; Dialog;</span><br><span class="line">Dialog.prototype.showButton &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;button:&#39; + this.button)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Tips(height, width, content, button, title) &#123;</span><br><span class="line">    Dialog.apply(this, arguments);</span><br><span class="line">    this.title &#x3D; title;</span><br><span class="line">&#125;</span><br><span class="line">Tips.prototype &#x3D; Object.create(Dialog.prototype);</span><br><span class="line">Tips.prototype.constructor &#x3D; Tips;</span><br><span class="line">Tips.prototype.showTitle &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;title:&#39; + this.title)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; *&#x2F;</span><br><span class="line"></span><br><span class="line">var tips &#x3D; new Tips(100,200,&#39;233333&#39;,&#39;ok&#39;,&#39;warn&#39;);</span><br><span class="line"></span><br><span class="line">console.log(tips.__proto__ &#x3D;&#x3D;&#x3D; Tips.prototype);                                     &#x2F;&#x2F; true</span><br><span class="line">console.log(tips.__proto__.__proto__ &#x3D;&#x3D;&#x3D; Dialog.prototype);                         &#x2F;&#x2F; true</span><br><span class="line">console.log(tips.__proto__.__proto__.__proto__ &#x3D;&#x3D;&#x3D; Modal.prototype);                &#x2F;&#x2F; true</span><br><span class="line">console.log(tips.__proto__.__proto__.__proto__.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype);     &#x2F;&#x2F; true</span><br><span class="line">console.log(tips.__proto__.__proto__.__proto__.__proto__.__proto__ &#x3D;&#x3D;&#x3D; null);       &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>tips对象的原型就是其构造函数Tips的属性prototype定义了一个对象，这个对象定义了constructor指向Tips，定义了showTitle方法；<br><br>同时通过create方法继承了构造函数Dialog的原型（Dialog.prototype），得到了showButton方法；<br><br>Dialog又继承了Modal的原型(Modal.prototype)，所以得到open方法；<br><br>Modal继承Object的原型(Object.prototype)，所以得到下面列一个Object原型上的属性和方法</p><ul><li><code>__defineGetter__</code></li><li><code>__defineSetter__</code></li><li><code>hasOwnProperty</code></li><li><code>__lookupGetter__</code></li><li><code>__lookupSetter__</code></li><li><code>propertyIsEnumerable</code></li><li><code>constructor</code></li><li><code>toString</code></li><li><code>toLocaleString</code></li><li><code>valueOf</code></li><li><code>isPrototypeOf</code></li><li><code>__proto__</code></li></ul><p>由于<strong>对象的原型上的方法和属性，对象本身可以通过<code>.</code>语法获取</strong>，所以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tips.open();&#x2F;&#x2F; width:200 ,height:100 ,content:233333</span><br><span class="line">tips.showButton();  &#x2F;&#x2F; button:ok</span><br><span class="line">tips.showTitle();&#x2F;&#x2F; title:warn</span><br><span class="line">tips.toString();    &#x2F;&#x2F; [object Object]</span><br></pre></td></tr></table></figure><h2 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h2><p>如果在Tips上定义的属性和原型链上的重复？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tips.prototype.toString &#x3D; function() &#123; console.log(&#39;new toString&#39;)&#125;</span><br><span class="line"></span><br><span class="line">tips.toString(); &#x2F;&#x2F; new toString</span><br></pre></td></tr></table></figure><p>原型链底下的会覆盖掉原型链顶上的的属性或方法。这也是很合理的</p><p>优先级最高的则是对象本身的的属性，即<strong>对象本身的方法或属性会覆盖掉原型上的方法或属性</strong></p><p>当一个对象调用一个属性或方法时，js解释器会先在当前对象上扫描是否有该属性，如果没有，才会到这个对象的原型上找，如果，还是没有，就到原型的原型上找，最后，直至Object.prototype,还是没有的话，就返回undefined</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;toString是从哪来的&quot;&gt;&lt;a href=&quot;#toString是从哪来的&quot; class=&quot;headerlink&quot; title=&quot;toString是从哪来的&quot;&gt;&lt;/a&gt;toString是从哪来的&lt;/h2&gt;&lt;p&gt;先来看一段代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var obj &amp;#x3D; &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(obj.toString()); &amp;#x2F;&amp;#x2F; 结果是：&amp;quot;[object Object]&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码很简单，一个对象调用了toString方法，但是如果我问你为什么可以调toString方法？toString是从哪来的？&lt;/p&gt;
&lt;p&gt;对于大多学过几天js的人知道，因为obj是继承了Object对象，而toString是Object对象的方法，所以obj可以调toString&lt;/p&gt;
&lt;p&gt;那么很明显，这个回答是正确的错误答案，因为关键字没有说到：&lt;strong&gt;原型&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器缓存测试情况</title>
    <link href="https://koro.fun/2016/12/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%B5%8B%E8%AF%95%E6%83%85%E5%86%B5/"/>
    <id>https://koro.fun/2016/12/22/浏览器缓存测试情况/</id>
    <published>2016-12-22T08:38:12.000Z</published>
    <updated>2018-01-31T09:44:23.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="no-cache的情况"><a href="#no-cache的情况" class="headerlink" title="no-cache的情况"></a>no-cache的情况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: image&#x2F;png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure><table><thead><tr><th>打开方式</th><th>chrome</th><th>safari</th><th>firefox</th></tr></thead><tbody><tr><td>刷新</td><td>304</td><td>304</td><td>304</td></tr><tr><td>链接打开</td><td>304</td><td>304</td><td>304</td></tr><tr><td>地址栏回车</td><td>304</td><td>304</td><td>304</td></tr></tbody></table><p>304的原因是：请求头里带上了If-Modified-Since，这个请求头是判断Last-Modified的时间是否大于http连接建立时间，没有大于，所以返回304</p><a id="more"></a><h2 id="no-store的情况"><a href="#no-store的情况" class="headerlink" title="no-store的情况"></a>no-store的情况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Content-Type: image&#x2F;png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure><table><thead><tr><th>打开方式</th><th>chrome</th><th>safari</th><th>firefox</th></tr></thead><tbody><tr><td>刷新</td><td>200</td><td>200</td><td>200</td></tr><tr><td>链接打开</td><td>200</td><td>200</td><td>200</td></tr><tr><td>地址栏回车</td><td>200</td><td>200</td><td>200</td></tr></tbody></table><h2 id="新鲜度有效的情况"><a href="#新鲜度有效的情况" class="headerlink" title="新鲜度有效的情况"></a>新鲜度有效的情况</h2><ul><li>在响应头中Cache Control 或Expiels没有的情况下</li><li>public</li><li>private</li><li>max-age=大于0的数值</li></ul><table><thead><tr><th>打开方式</th><th>chrome</th><th>safari</th><th>firefox</th></tr></thead><tbody><tr><td>刷新</td><td>from cache</td><td>304</td><td>304</td></tr><tr><td>链接打开</td><td>from cache</td><td>from cache</td><td>from cache</td></tr><tr><td>地址栏回车</td><td>from cache</td><td>from cache</td><td>from cache</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><p>Safari和firefox在刷新的时候出现304是因为刷新时浏览器在请求头上设置了<code>Cache-Control: max-age=0</code>，而chrome并不会</p></li><li><p>对于刚刚修改了的文件，且没有设置max-age或max-age很小的，二次加载资源的时间和第一次加载资源的时间间隔较长，是不会出现以下的结果，因为新鲜度是有时间限制的, 修改时间离请求建立时间越短，新鲜度有效期越短，（说明这个文件改动频繁，就不需要缓存太长时间）</p><blockquote><p>max-age = (Date.now() - Last-Modified) * 10%</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;no-cache的情况&quot;&gt;&lt;a href=&quot;#no-cache的情况&quot; class=&quot;headerlink&quot; title=&quot;no-cache的情况&quot;&gt;&lt;/a&gt;no-cache的情况&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HTTP&amp;#x2F;1.1 200 OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Cache-Control: no-cache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Content-Type: image&amp;#x2F;png&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Accept-Ranges: bytes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Date: Thu, 10 Nov 2016 02:48:50 GMT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Content-Length: 3534&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;打开方式&lt;/th&gt;
&lt;th&gt;chrome&lt;/th&gt;
&lt;th&gt;safari&lt;/th&gt;
&lt;th&gt;firefox&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;刷新&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;链接打开&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;地址栏回车&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;304的原因是：请求头里带上了If-Modified-Since，这个请求头是判断Last-Modified的时间是否大于http连接建立时间，没有大于，所以返回304&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://koro.fun/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="缓存" scheme="https://koro.fun/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题</title>
    <link href="https://koro.fun/2016/12/21/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://koro.fun/2016/12/21/跨域问题/</id>
    <published>2016-12-21T14:46:49.000Z</published>
    <updated>2017-01-03T06:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>什么是同源，满足三个条件相同</p><ul><li>协议, http与https不同源</li><li>端口，80与8080 不同源</li><li>主机 <a href="http://www.company.com与store.company.com不同源" target="_blank" rel="noopener">www.company.com与store.company.com不同源</a></li></ul><p>Ps. IE例外：不考虑端口；Trust Zones（可信任的域）的域名可以看作是同源</p><h3 id="同源策略的限制"><a href="#同源策略的限制" class="headerlink" title="同源策略的限制"></a>同源策略的限制</h3><ul><li>通常允许进行跨域写操作（Cross-origin writes）。例如链接（links），重定向以及表单提交。</li><li>通常允许跨域资源嵌入（Cross-origin embedding）。就是跨域标签了<code>&lt;scipt&gt;</code>,<code>&lt;link&gt;</code>,<code>&lt;img&gt;</code>,<code>&lt;video&gt;</code>,<code>&lt;object&gt;</code>,<code>&lt;iframe&gt;</code></li><li>通常不允许跨域读操作（Cross-origin reads）。但常可以通过内嵌资源来巧妙的进行读取访问。</li></ul><a id="more"></a><h3 id="如何阻止跨源访问"><a href="#如何阻止跨源访问" class="headerlink" title="如何阻止跨源访问"></a>如何阻止跨源访问</h3><ul><li>阻止跨域写操作，只要检测请求中的一个不可测的标记(CSRF token)即可，这个标记被称为Cross-Site Request Forgery (CSRF) 标记。必须使用这个标记来阻止页面的跨站读操作。</li><li>阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。</li><li>阻止跨站嵌入，确保你得资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守Conten-Type消息头。例如，如果你在<code>&lt;script&gt;</code>标签中嵌入HTML文档，浏览器仍将HTML解析为Javascript。当你的资源入口不是指向你的网站, 你同样可以使用CSRF token阻止它嵌入.</li></ul><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>如果是父子域跨域的情况，可以通过修改document.domain实现父子域同源 </p><p>如站点store.company.com, 需要访问company.com/api</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.domain &#x3D; &#39;company.com&#39;</span><br></pre></td></tr></table></figure><p>(待验证)</p><h2 id="HTTP控制访问CORS"><a href="#HTTP控制访问CORS" class="headerlink" title="HTTP控制访问CORS"></a>HTTP控制访问CORS</h2><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>如：get一个数据</p><p>post也可以，但是Content-Type只能是这三种之一</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul><h3 id="预请求"><a href="#预请求" class="headerlink" title="预请求"></a>预请求</h3><p>先发一个options请求，再发正式请求</p><p>如：上传文件，想要使用自定义的请求头，如：x-modified</p><h3 id="响应头说明"><a href="#响应头说明" class="headerlink" title="响应头说明"></a>响应头说明</h3><h4 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h4><p>允许来自哪些域的请求<br><br>出于安全性的考虑，如果客户端xhr指定了<code>withCredentials=true</code>，那么这个值是不能为<code>*</code>，必须指定有哪些域可访问的，确保了登陆态只能给我事前设置好的站点，</p><h4 id="Access-Control-Expose-Headers"><a href="#Access-Control-Expose-Headers" class="headerlink" title="Access-Control-Expose-Headers"></a>Access-Control-Expose-Headers</h4><p>指定浏览器可以得到服务器的那些自定义的响应头信息，在预请求中,而不是正式请求，这和Access-Control-Allow-Headers是不一样的，这些头预请求的响应头，而不是正式请求的请求头</p><h4 id="Access-Control-Max-Age"><a href="#Access-Control-Max-Age" class="headerlink" title="Access-Control-Max-Age"></a>Access-Control-Max-Age</h4><p>预请求的结果的有效期是多少，单位（秒）<br><br>浏览器关掉后就无效了，应该是这样，待验证</p><h4 id="Access-Control-Allow-Credentials"><a href="#Access-Control-Allow-Credentials" class="headerlink" title="Access-Control-Allow-Credentials"></a>Access-Control-Allow-Credentials</h4><p>首先这个响应头的值是true或false，如果是true，服务端才把响应数据返回给客户的，否则不返回</p><p>服务端是会根据客户端传过来的cookie判断身份信息是否有效，然后决定返回true还是false？？</p><p>客户端xhr中的<code>withCredentials</code>属性可以决定客户端是不是要把cookie信息带上给服务端</p><p>在用一个站点下使用<code>withCredentials</code>属性是无效的。</p><h4 id="Access-Control-Allow-Methods"><a href="#Access-Control-Allow-Methods" class="headerlink" title="Access-Control-Allow-Methods"></a>Access-Control-Allow-Methods</h4><p>告诉客户端，服务端同意这些请求的方式，比如：get post options</p><h4 id="Access-Control-Allow-Headers"><a href="#Access-Control-Allow-Headers" class="headerlink" title="Access-Control-Allow-Headers"></a>Access-Control-Allow-Headers</h4><p>预请求中指定服务器在<strong>正式</strong>的请求中会识别哪些请求头,就是预请求服务同意了哪些header，告诉客户端可以发起Access-Control-Request-Headers</p><h3 id="请求头说明"><a href="#请求头说明" class="headerlink" title="请求头说明"></a>请求头说明</h3><h4 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h4><p>告诉服务器端，这个请求的来源是哪里，这个值当然就是请求当前所处的域，不包含任何路径信息</p><h4 id="Access-Control-Request-Method"><a href="#Access-Control-Request-Method" class="headerlink" title="Access-Control-Request-Method"></a>Access-Control-Request-Method</h4><p>告诉服务端，实际请求的方式是什么</p><h4 id="Access-Control-Request-Headers"><a href="#Access-Control-Request-Headers" class="headerlink" title="Access-Control-Request-Headers"></a>Access-Control-Request-Headers</h4><p>告诉服务端，自定义的header是哪些</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>移动端可以认为全兼容</p><p>PC端，Internet Explorer 8 和 9 通过 XDomainRequest 对象来实现CORS，其他也都ok</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;p&gt;什么是同源，满足三个条件相同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协议, http与https不同源&lt;/li&gt;
&lt;li&gt;端口，80与8080 不同源&lt;/li&gt;
&lt;li&gt;主机 &lt;a href=&quot;http://www.company.com与store.company.com不同源&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.company.com与store.company.com不同源&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ps. IE例外：不考虑端口；Trust Zones（可信任的域）的域名可以看作是同源&lt;/p&gt;
&lt;h3 id=&quot;同源策略的限制&quot;&gt;&lt;a href=&quot;#同源策略的限制&quot; class=&quot;headerlink&quot; title=&quot;同源策略的限制&quot;&gt;&lt;/a&gt;同源策略的限制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通常允许进行跨域写操作（Cross-origin writes）。例如链接（links），重定向以及表单提交。&lt;/li&gt;
&lt;li&gt;通常允许跨域资源嵌入（Cross-origin embedding）。就是跨域标签了&lt;code&gt;&amp;lt;scipt&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通常不允许跨域读操作（Cross-origin reads）。但常可以通过内嵌资源来巧妙的进行读取访问。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://koro.fun/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于304缓存与200from cache缓存</title>
    <link href="https://koro.fun/2016/12/21/%E5%85%B3%E4%BA%8E304%E7%BC%93%E5%AD%98%E4%B8%8E200from-cache%E7%BC%93%E5%AD%98/"/>
    <id>https://koro.fun/2016/12/21/关于304缓存与200from-cache缓存/</id>
    <published>2016-12-21T14:46:49.000Z</published>
    <updated>2017-01-03T06:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们常见的浏览器缓存有两种，一种状态码是200，size显示是from-cache，另一种状态码是304，也就是通常我们说的304缓存</p><p>根据<a href="https://tools.ietf.org/html/rfc7234" target="_blank" rel="noopener">HTTP协议规范</a>的定义，浏览器的缓存机制分为两块，也就是规范中的4.2. Freshness 和 4.3. Validation。</p><ul><li>Freshness（新鲜度），这个条件成立，就是200 from cache缓存，</li><li>Validation（验证），当Freshness不成立时，就要看Validation，成立就是304缓存，不成立，拉取的就是新数据</li></ul><p>但是实际情况，某些浏览器并不是完全按照协议来实现缓存机制的，这个后面讲，先看Freshness和Validation是什么东西</p><h2 id="Freshness（新鲜度）"><a href="#Freshness（新鲜度）" class="headerlink" title="Freshness（新鲜度）"></a>Freshness（新鲜度）</h2><p>决定一个资源是不是足够新鲜，需要看资源的两个响应头Expires和Cache Control，他们是用来进行Freshness验证，也就是提供客户端检测文件是否足够新鲜，可以无需向服务端发起Validation请求就能保证并未过期可以直接使用。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>http1.0版本定义的，明确的过期时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expires:Sat, 30 Dec 2017 00:52:32 GMT</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache Control"></a>Cache Control</h3><p>为什么要有Cache Control是由于历史原因，在HTTP1.0中定义的是Expires，Expires的值是一个明确的过期时间，是服务端时间，而后来使用中发现一旦客户端时间与服务器时间不一致就会引发很多缓存问题。所以在HTTP1.1中增加了Cache Control，其中的max-age是一个数值，单位（秒），告知客户端这个文件多长时间不会过期而不是直接告知过期时间。</p><p>如下，告诉客户端这个资源有效期一年</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control:public, max-age&#x3D;31536000</span><br></pre></td></tr></table></figure><p>详细看下Cache Control的值有哪些，因为Cache Control是通用Header，所以当时做为请求头和响应头时，其值的作用是不一样的</p><p>Cache-Control作为请求头的时候，是浏览器期望服务器返回什么的资源，有以下这些值，no-cache，no-store，max-age，max-state，min-fresh，no-transform，only-if-cached</p><p>Cache-Control作为响应头的时候，可以有以下这些值：public，private，no-cache，no-store，no-transform，must-revalidate，proxy-revalidate，max-age，s-maxage，cache-extension</p><p>这里很多值是给缓存服务器用的，对于浏览器端，主要说三种情况</p><h4 id="no-store"><a href="#no-store" class="headerlink" title="no-store"></a>no-store</h4><p>这个值出现时，<strong>浏览器完全不缓存资源</strong>，所以不管新鲜度还是验证的都没啥事了，没有200 from cache，也没有304，每次请求都是重新向服务器拉新的资源</p><h4 id="max-age大于0"><a href="#max-age大于0" class="headerlink" title="max-age大于0"></a>max-age大于0</h4><p>首先缓存资源，然后资源的新鲜度是当前时间 + max-age指定的时间</p><h4 id="no-cache-或-max-age-0"><a href="#no-cache-或-max-age-0" class="headerlink" title="no-cache 或 max-age=0"></a>no-cache 或 max-age=0</h4><p>这两种可以理解为是一样的，即缓存资源，但其新鲜度立即过期，也就是一定需要发起Validation的</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>比如没有配置Cache Control的情况（同时也没有配置Expires），其实这种情况是很多的，或者配置的是public，private之类的</p><p>这个时候资源的新鲜度有效期是是http连接建立时间减去文件最后修改时间的10%</p><p>可以这样理解</p><p><code>max-age = (Date - Last-Modified) * 10%</code><br><br>或<br><br><code>expires: 当前时间 + (Date - Last-Modified) * 10%</code></p><p>从上面的公式可以看出，如果一个资源刚被修改过，那么新鲜度时间就会很短，反之，如果长时间没被改动过，那么其新鲜度时间就会很长</p><hr><p>所有的from cache的请求实际上都是由于浏览器认为本地的缓存资源足够新鲜，所以并没有发起http请求，而是直接从硬盘(from-disk-cache)或内存(from-memory-cache)中读取上次缓存的资源</p><p>缓存在硬盘重要不清空缓存，缓存有效期内，资源都是在的，和浏览器重不重启没有关系</p><h3 id="如何更新这种缓存"><a href="#如何更新这种缓存" class="headerlink" title="如何更新这种缓存"></a>如何更新这种缓存</h3><p>所以资源被缓存后，更新版本时，就需要给资源加上时间戳，否则，是没法刷新缓存的，你不能指望的用户发现内容不对时还清空缓存试试</p><p>关于时间戳可以看这篇<br><a href="http://mp.weixin.qq.com/s/Mxgig7-F735xSWnoKEe5Vg" target="_blank" rel="noopener">非覆盖式静态资源发布</a></p><h2 id="Validation（验证）"><a href="#Validation（验证）" class="headerlink" title="Validation（验证）"></a>Validation（验证）</h2><p>Last-Modified和ETag则是另一组控制信息，他们用来实现Validation。他们的职责是在本地缓存被浏览器判断可能不够新鲜的时候，<strong>会用这两组信息向服务器请求数据</strong>，如果服务器内容没有改变，那么约定服务器会返回304 HTTP Code表明这个缓存可以直接使用，无需重新拉取，而一旦服务器内容改变了就会返回200，同时返回新的文件内容。</p><p>所以Validation的意思是向服务端发送请求，Last-Modified或ETag验证资源是否有改动来判断是非使用缓存，所以304缓存是存在一个TTR时间（完成一次请求响应回路）</p><h3 id="Last-Modified-http1-0"><a href="#Last-Modified-http1-0" class="headerlink" title="Last-Modified(http1.0)"></a>Last-Modified(http1.0)</h3><p>表示的是文件最后修改的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified:Wed, 28 Dec 2016 14:31:40 GMT</span><br></pre></td></tr></table></figure><h3 id="ETag-http1-1"><a href="#ETag-http1-1" class="headerlink" title="ETag(http1.1)"></a>ETag(http1.1)</h3><p>有了前面的Cache-Control铺垫，这里的ETag也很好理解了</p><p>Last-Modified的缺点：</p><ul><li>只有秒级精度，如果一秒内有多次修改，缓存会有问题，这算什么问题？？？</li><li>如果文件不是正常更新的，比如一个老文件覆盖了新的文件，这…确实有问题，比如想滚回老版本，不过即使是老版本，发布前重新构建后也就不存在旧文件覆盖文件的问题了</li><li>如果一个文件被修改，但是内容并没有变化，这时候我们喜欢不刷新缓存，但是Last-Modified只看文件修改日期，过期就刷新缓存，不管内容有没有变化</li></ul><p>HTTP1.1中新引入了ETag，他的实现不尽相同，对于动态内容，常规做法是</p><ul><li>动态内容做HASH计算，作为ETAG返回</li><li>静态资源，一般是使用inode+mtime进行计算。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag:&quot;215d-53838ca8b3cc0&quot;</span><br></pre></td></tr></table></figure><p>But，在分布式系统中，相同文件在不同机器上的的inode是不一样的，这就导致了ETag不一样，进而导致304失效，所以实际使用上是会关闭ETag，还是依靠Last-Modified来做Validation判断</p><h2 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h2><p>实际上我在Chrome中打开控制台看到，很多情况，不管Expires和Cache Control有没有效，缓存都是200 from cache，<br>而当我打开Safari时，304出来了, 如下图，上面Safari，下面是Chrome<br><img src="http://caidewu-blog-img.qiniudn.com/chrome304.png?imageView2/2/w/800" alt=""></p><h3 id="浏览器行为"><a href="#浏览器行为" class="headerlink" title="浏览器行为"></a>浏览器行为</h3><p>对于加载一个页面，我们通常有三种方式</p><ul><li>输入url，回车打开页面</li><li>链接打开</li><li>刷新</li></ul><p>对于静态资源缓存的处理，我测试的情况是，输入url和链接打开行为都是一致的，不一样的在于刷新</p><p>Safari和Firefox在刷新时，都会加在一个请求头 <code>Cache-Control: max-age=0</code>,也就是说，刷新的时候，即使资源是新鲜的，浏览器也会发起Validation，然后返回304</p><p>而Chrome在刷新时并不会带上<code>Cache-Control: max-age=0</code>，所以上图的情况就解释的通了</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><blockquote><ul><li><a href="https://tools.ietf.org/html/rfc7234#section-4.2.2" target="_blank" rel="noopener"> Hypertext Transfer Protocol (HTTP/1.1)</a></li><li><a href="http://mp.weixin.qq.com/s/qOMO0LIdA47j3RjhbCWUEQ" target="_blank" rel="noopener">彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法</a></li><li><a href="http://www.oschina.net/code/snippet_130291_14275" target="_blank" rel="noopener">Nginx只缓存静态文件配置</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们常见的浏览器缓存有两种，一种状态码是200，size显示是from-cache，另一种状态码是304，也就是通常我们说的304缓存&lt;/p&gt;
&lt;p&gt;根据&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP协议规范&lt;/a&gt;的定义，浏览器的缓存机制分为两块，也就是规范中的4.2. Freshness 和 4.3. Validation。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Freshness（新鲜度），这个条件成立，就是200 from cache缓存，&lt;/li&gt;
&lt;li&gt;Validation（验证），当Freshness不成立时，就要看Validation，成立就是304缓存，不成立，拉取的就是新数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是实际情况，某些浏览器并不是完全按照协议来实现缓存机制的，这个后面讲，先看Freshness和Validation是什么东西&lt;/p&gt;
&lt;h2 id=&quot;Freshness（新鲜度）&quot;&gt;&lt;a href=&quot;#Freshness（新鲜度）&quot; class=&quot;headerlink&quot; title=&quot;Freshness（新鲜度）&quot;&gt;&lt;/a&gt;Freshness（新鲜度）&lt;/h2&gt;&lt;p&gt;决定一个资源是不是足够新鲜，需要看资源的两个响应头Expires和Cache Control，他们是用来进行Freshness验证，也就是提供客户端检测文件是否足够新鲜，可以无需向服务端发起Validation请求就能保证并未过期可以直接使用。&lt;/p&gt;
&lt;h3 id=&quot;Expires&quot;&gt;&lt;a href=&quot;#Expires&quot; class=&quot;headerlink&quot; title=&quot;Expires&quot;&gt;&lt;/a&gt;Expires&lt;/h3&gt;&lt;p&gt;http1.0版本定义的，明确的过期时间&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;expires:Sat, 30 Dec 2017 00:52:32 GMT&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="https://koro.fun/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="缓存" scheme="https://koro.fun/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>详细说一下这道js面试题</title>
    <link href="https://koro.fun/2016/12/16/%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%BF%99%E9%81%93js%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://koro.fun/2016/12/16/详细说一下这道js面试题/</id>
    <published>2016-12-16T09:42:53.000Z</published>
    <updated>2017-01-03T06:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天面试遇到的一个问题，关于js的基本语法问题，因为我做错了，所以这种题目很无聊，额…严肃的说，其实这道题还是考察了挺多东西的，所以还是要拿来说说</p></blockquote><h2 id="先看题目"><a href="#先看题目" class="headerlink" title="先看题目"></a>先看题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Dog() &#123;</span><br><span class="line">  a &#x3D; function() &#123;console.log(&#39;1&#39;)&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Dog.a &#x3D; function() &#123;console.log(&#39;2&#39;)&#125;;</span><br><span class="line">Dog.prototype.a &#x3D; function() &#123;console.log(&#39;3&#39;)&#125;;</span><br><span class="line">var a &#x3D; function() &#123;console.log(&#39;4&#39;)&#125;;</span><br><span class="line">function a() &#123;console.log(&#39;5&#39;)&#125;</span><br></pre></td></tr></table></figure><p>下面代码会输出什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a();</span><br><span class="line">Dog.a();</span><br><span class="line">a();</span><br><span class="line">Dog.a();</span><br><span class="line">new Dog.a();</span><br><span class="line">new Dog().a;</span><br><span class="line">new new Dog().a;</span><br></pre></td></tr></table></figure><a id="more"></a><p>先来看下这道题考查的点：</p><ul><li>抗压能力</li><li>函数式声明提升</li><li>变量作用域</li><li>全局变量</li><li>js运算符优先级</li><li>构造函数</li><li>new关键字</li><li>prototype方法</li></ul><h2 id="分析下题目"><a href="#分析下题目" class="headerlink" title="分析下题目"></a>分析下题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个构造函数</span><br><span class="line">function Dog() &#123;</span><br><span class="line">  a &#x3D; function() &#123;console.log(&#39;1&#39;)&#125;; &#x2F;&#x2F; 这里的a是全局变量</span><br><span class="line">&#125;</span><br><span class="line">Dog.a &#x3D; function() &#123;console.log(&#39;2&#39;)&#125;; &#x2F;&#x2F;Dog虽然是个构造函数，但函数本质上也是对象，挂个属性没毛病 （但平时不会这么写代码）</span><br><span class="line">Dog.prototype.a &#x3D; function() &#123;console.log(&#39;3&#39;)&#125;; &#x2F;&#x2F; 这是正常给构造函数挂个方法，实例对象会用到这个方法</span><br><span class="line">var a &#x3D; function() &#123;console.log(&#39;4&#39;)&#125;; </span><br><span class="line">function a() &#123;console.log(&#39;5&#39;)&#125; &#x2F;&#x2F; 函数式声明会整体提升的</span><br></pre></td></tr></table></figure><h2 id="一个一个来"><a href="#一个一个来" class="headerlink" title="一个一个来"></a>一个一个来</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><blockquote><p>为了简单说明，下面用a函数输出的数字来代表a分别是哪个a</p></blockquote><p>因为5这个函数式声明，函数式声明会被提前至外部脚本或外部作用域顶部，所以5是最先被定义的</p><p>然后来看1里的a，没有var，是全局变量，相当于a在第一行声明，不过因为有5的存在（已经声明并且定义），这个声明就是指向5的</p><p>2和3都是Dog的作用域下，和这个无关</p><p>代码分析到这里为止的话， <code>a();</code> 结果应该是5</p><p>因为4这里a被重新赋值，所以 <code>a();</code> 结果是4</p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>Dog虽然是构造函数，它也是个函数，但首先它是一个对象</p><blockquote><p>就好比你是小学生，小学生也是学生，但首先你是一个人</p></blockquote><p>所以Dog在这里就是对象，a就是它的一个属性而已，而这个属性是个方法，（）执行这个方法，所以结果是2</p><h3 id="第三、四题"><a href="#第三、四题" class="headerlink" title="第三、四题"></a>第三、四题</h3><p>第三题和第四题问的一样，如果我还是小学生的时候，我就会举手问老师：老师这个题是不是出错了？</p><p>但是从以往的面试题来说这里一定是个陷阱，因为<code>a()</code>执行了一次，再执行一次的话。。。。。。。。。。他妈的不还是一样，函数体内都是写死的东西啊，<code>Dog.a()</code>同理，不过面试高度紧张的时候，往往就不敢相信这是道送分题啊</p><h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Dog.a();</span><br></pre></td></tr></table></figure><p>看到new的时候，Dog作为一个构造函数应该在感慨终于轮到我登场了，然而现实却狠狠的打了它的脸。因为 <code>.</code>的优先级是高于<code>new</code>的, </p><blockquote><p>属性访问表达式和调用表达式的优先级比所有的运算符都要高</p></blockquote><p>所以被new的是<code>Dog.a</code>，而<code>Dog.a</code>是一个普通的函数，但是我们要知道<strong>构造函数是一种约定的名称，事实上任何函数都可以被new出一个对象</strong>，只是这种对象没什么卵用</p><p>那么久要看new这个过程到底发生了什么, 有兴趣可以参考旧文</p><blockquote><p><a href="https://caidewu.cc/2016/03/09/Javascript%E4%B8%AD%E7%9A%84new%E5%85%B3%E9%94%AE%E5%AD%97/" target="_blank" rel="noopener">Javascript中的new关键字</a> </p></blockquote><p>这里只说一点，new的时候，被new的函数会执行，所以这就和第二相同，结果是2</p><h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Dog().a;</span><br></pre></td></tr></table></figure><p>如果没有第五题，这道题没什么特别的，但是经历第五题的各种优先级问题，你会怀疑自己，到底哪个先执行啊</p><p>首先<code>()</code>,<code>[]</code>,<code>.</code>这个是最高优先级同级的，谁靠左边，最先执行</p><p>所以这里先不管<code>.a</code>,那么就是<code>new Dog()</code>,这个的结果是让身为构造函数的Dog表示很欣慰，终于new出个正儿八经的对象了，</p><p>这个对象有一个方法，没错就是挂在其构造函数Dog的prototype上的a</p><p>所以这个执行的结果是没有console任何东西，这个a还没执行</p><h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new new Dog().a;</span><br></pre></td></tr></table></figure><p>第六题明白了，这道题就是送分题了,再加一个new，优先级当然是在最后了，执行过程同下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ((new Dog()).a)</span><br></pre></td></tr></table></figure><p>第六题的结果是a这个函数，普通函数呗new，就一定有函数被执行的过程，那么a执行就会打印出3</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这种问题，做错也没什么，人的记性毕竟有时候就是不太可靠，但是分析过程要懂，说白了就是看着参考答案你要说的出来为什么，如果语法不过关是做不到这点</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天面试遇到的一个问题，关于js的基本语法问题，因为我做错了，所以这种题目很无聊，额…严肃的说，其实这道题还是考察了挺多东西的，所以还是要拿来说说&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;先看题目&quot;&gt;&lt;a href=&quot;#先看题目&quot; class=&quot;headerlink&quot; title=&quot;先看题目&quot;&gt;&lt;/a&gt;先看题目&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function Dog() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a &amp;#x3D; function() &amp;#123;console.log(&amp;#39;1&amp;#39;)&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Dog.a &amp;#x3D; function() &amp;#123;console.log(&amp;#39;2&amp;#39;)&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Dog.prototype.a &amp;#x3D; function() &amp;#123;console.log(&amp;#39;3&amp;#39;)&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var a &amp;#x3D; function() &amp;#123;console.log(&amp;#39;4&amp;#39;)&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function a() &amp;#123;console.log(&amp;#39;5&amp;#39;)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面代码会输出什么：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Dog.a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Dog.a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dog.a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Dog().a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new new Dog().a;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://koro.fun/tags/javascript/"/>
    
      <category term="面试题" scheme="https://koro.fun/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>在Mac中统计代码行数，find的命令怎么用</title>
    <link href="https://koro.fun/2016/12/14/%E5%9C%A8Mac%E4%B8%AD%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/"/>
    <id>https://koro.fun/2016/12/14/在Mac中统计代码行数/</id>
    <published>2016-12-14T02:54:38.000Z</published>
    <updated>2016-12-27T17:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先来看怎么用"><a href="#先来看怎么用" class="headerlink" title="先来看怎么用"></a>先来看怎么用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 统计文件类型是&#96;*.m&#96;,&#96;*.mm&#96;,&#96;*.cpp&#96;,&#96;*.h&#96;,&#96;*.rss&#96;的文件代码行数</span><br><span class="line">find . &quot;(&quot; -name &quot;*.m&quot; -or -name &quot;*.mm&quot; -or -name &quot;*.cpp&quot; -or -name &quot;*.h&quot; -or -name &quot;*.rss&quot; &quot;)&quot; | xargs wc -l</span><br><span class="line"> </span><br><span class="line"># 统计js文件行数</span><br><span class="line">find . &quot;(&quot; -name &quot;*.js&quot; &quot;)&quot; | xargs wc -l</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="仔细看一下"><a href="#仔细看一下" class="headerlink" title="仔细看一下"></a>仔细看一下</h3><p>这条命令主要包含两部分，</p><ul><li>find</li><li>wc</li></ul><p>find是过滤出想要统计的文件，wc是统计，他们中间通过<code>|</code>管道连接</p><p><strong>xargs</strong>：由于很多命令不支持<code>|</code>管道来传递参数</p><p>xargs 可以读入 stdin 的资料，并且以空白字元或断行字元作为分辨，将 stdin 的资料分隔成为 arguments 。</p><p><strong>find .</strong>: 列出当前目录及子目录下所有文件和文件夹 </p><p>来自: <a href="http://man.linuxde.net/find" target="_blank" rel="noopener">http://man.linuxde.net/find</a></p><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><blockquote><p><a href="http://man.linuxde.net/wc" target="_blank" rel="noopener">http://man.linuxde.net/wc</a></p></blockquote><ul><li>-c或–bytes或——chars：只显示Bytes数；</li><li>-l或——lines：只显示列数； </li><li>-w或——words：只显示字数。</li></ul><p>如果不带参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  public  &gt;wc index.html</span><br><span class="line">     117     627   14703 index.html</span><br><span class="line">  行数  Bytes数  字数</span><br></pre></td></tr></table></figure><p>来自: <a href="http://man.linuxde.net/wc" target="_blank" rel="noopener">http://man.linuxde.net/wc</a></p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><blockquote><p><a href="http://man.linuxde.net/find" target="_blank" rel="noopener">http://man.linuxde.net/find</a></p></blockquote><h4 id="忽略某个子目录"><a href="#忽略某个子目录" class="headerlink" title="忽略某个子目录"></a>忽略某个子目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . &quot;.&#x2F;node_modules&quot; -prune</span><br></pre></td></tr></table></figure><ul><li><code>-o</code>: 等同<code>-or</code>， 或的意思，类似的条件判断还有与<code>-a</code>,非<code>!</code> </li></ul><h4 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;home -iname &quot;HelloWorld.txt&quot;</span><br><span class="line"></span><br><span class="line">可以匹配上</span><br><span class="line">helloworld.txt</span><br><span class="line">HELLOWORLD.txt</span><br><span class="line">Helloworld.TXT</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="匹配文件路径或文件"><a href="#匹配文件路径或文件" class="headerlink" title="匹配文件路径或文件"></a>匹配文件路径或文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 文件夹或文件名包含local</span><br><span class="line">find &#x2F;usr&#x2F; -path &quot;*local*&quot;</span><br><span class="line"></span><br><span class="line"># 文件夹包含local</span><br><span class="line">find &#x2F;usr&#x2F; -path &quot;*&#x2F;local&#x2F;*&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>-path</strong>: 指定字符串作为寻找目录的关键字</li></ul><h4 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure><h4 id="根据文件大小来搜索"><a href="#根据文件大小来搜索" class="headerlink" title="根据文件大小来搜索"></a>根据文件大小来搜索</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 搜索大于1G的文件</span><br><span class="line">find . -type f -size +1G</span><br><span class="line"></span><br><span class="line">find . -type f -size -1k</span><br></pre></td></tr></table></figure><ul><li>b —— 块（512字节） </li><li>c —— 字节 </li><li>w —— 字（2字节） </li><li>k —— 千字节 </li><li>M —— 兆字节 </li><li>G —— 吉字节</li></ul><p>#### </p><h4 id="根据文件性质来分类"><a href="#根据文件性质来分类" class="headerlink" title="根据文件性质来分类"></a>根据文件性质来分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有目录</span><br><span class="line">find . -type d</span><br></pre></td></tr></table></figure><ul><li>f 普通文件 </li><li>l 符号连接 </li><li>d 目录 </li><li>c 字符设备 </li><li>b 块设备 </li><li>s 套接字 </li><li>p Fifo</li></ul><h4 id="基于目录深度搜索"><a href="#基于目录深度搜索" class="headerlink" title="基于目录深度搜索"></a>基于目录深度搜索</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 向下深度限制为3</span><br><span class="line">find . -maxdepth 3 -type f</span><br><span class="line"></span><br><span class="line"># 向下深度超过2的文件</span><br><span class="line">find . -mindepth 2 -type f</span><br></pre></td></tr></table></figure><h4 id="要列出所有长度为零的文件"><a href="#要列出所有长度为零的文件" class="headerlink" title="要列出所有长度为零的文件"></a>要列出所有长度为零的文件</h4><p>来自: <a href="http://man.linuxde.net/find" target="_blank" rel="noopener">http://man.linuxde.net/find</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -empty</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;先来看怎么用&quot;&gt;&lt;a href=&quot;#先来看怎么用&quot; class=&quot;headerlink&quot; title=&quot;先来看怎么用&quot;&gt;&lt;/a&gt;先来看怎么用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 统计文件类型是&amp;#96;*.m&amp;#96;,&amp;#96;*.mm&amp;#96;,&amp;#96;*.cpp&amp;#96;,&amp;#96;*.h&amp;#96;,&amp;#96;*.rss&amp;#96;的文件代码行数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find . &amp;quot;(&amp;quot; -name &amp;quot;*.m&amp;quot; -or -name &amp;quot;*.mm&amp;quot; -or -name &amp;quot;*.cpp&amp;quot; -or -name &amp;quot;*.h&amp;quot; -or -name &amp;quot;*.rss&amp;quot; &amp;quot;)&amp;quot; | xargs wc -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 统计js文件行数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find . &amp;quot;(&amp;quot; -name &amp;quot;*.js&amp;quot; &amp;quot;)&amp;quot; | xargs wc -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="shell" scheme="https://koro.fun/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>华为交换机配置</title>
    <link href="https://koro.fun/2016/12/13/%E5%BD%93%E7%BD%91%E7%AE%A1%E7%B3%BB%E5%88%97/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%85%8D%E7%BD%AE/"/>
    <id>https://koro.fun/2016/12/13/当网管系列/华为交换机配置/</id>
    <published>2016-12-13T14:16:39.000Z</published>
    <updated>2016-12-27T17:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先要连上设备"><a href="#先要连上设备" class="headerlink" title="先要连上设备"></a>先要连上设备</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>一台电脑（Windows系统，或是虚拟机都可以）</li><li>一根console线（RJ45转R232串口的线）</li><li>一个R232转USB线（如果电脑有串口可以忽略）</li><li>USB 2.0 To COM Device驱动（如果电脑有串口可以忽略）</li><li>超级终端（win7以上需要）</li></ol><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>把console线接到交换机的console口中，然后接串口转USB线，然后接电脑，如果是2016MBP，你还得转接Type-c。。。 holy shit！！！</p><p>先装驱动：USB 2.0 To COM Device</p><p>打开超级终端，没有说到的参数，随便写，</p><p>串行选项中，需要配置</p><ol><li>端口，看设备管理里是COM几被连接上</li><li>波特率：9600</li><li>数据位：8</li><li>奇偶校验：无</li><li>停止位：1</li></ol><a id="more"></a><p>然后就可以连接上了，<strong>需要按一下回车</strong>，才显示提示输入密码的东西</p><p><img src="http://caidewu-blog-img.qiniudn.com/switch-IMG_2763.JPG" alt=""></p><h2 id="忘记密码怎么办，重置大法好"><a href="#忘记密码怎么办，重置大法好" class="headerlink" title="忘记密码怎么办，重置大法好"></a>忘记密码怎么办，重置大法好</h2><p>交换机的BootROM(类似电脑的Bios)提供了清除Console口登录密码的功能，用户可以在交换机启动后修改Console口登录密码，然后保存配置。请按照如下步骤进行配置。</p><ol><li>通过Console口连接交换机，并重启交换机，拔电源！！！，再插上</li></ol><p>当超级终端的界面出现“Press Ctrl+B to enter boot menu”或者“Press Ctrl+B or Ctrl+E to enter BootROM menu”（仅E系列和某些S系列盒式交换机支持）以下打印信息时，</p><p>及时按下快捷键“Ctrl+B”或者“Ctrl+E”并输入BootROM密码，进入BootROM主菜单。</p><p>密码说明： </p><ul><li>E系列交换机BootROM默认密码为<a href="mailto:`Admin@huawei.com">`Admin@huawei.com</a>`。 </li><li><p>S系列盒式交换机在V100R006C05之前的版本，BootROM默认密码为<code>huawei</code>；</p><ul><li>在V100R006C05及之后的版本，默认密码为<a href="mailto:`Admin@huawei.com">`Admin@huawei.com</a>`。</li></ul></li><li><p>S系列框式交换机在V100R006C00之前的版本，BootROM默认密码为<code>9300</code>；</p><ul><li>在V100R006C00及之后的版本，默认密码为<a href="mailto:`Admin@huawei.com">`Admin@huawei.com</a>`。</li></ul></li></ul><ol start="2"><li>在BootROM主菜单下选择“Clear password for console user”清除Console口登录密码。</li><li>根据交换机的提示，在BootROM主菜单下选择“Boot with default mode”启动设备。</li><li>完成系统启动后，首先会让你初始化交换机密码，设置好后进入交换机</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Quidway]</span><br></pre></td></tr></table></figure><h2 id="恢复出厂设置"><a href="#恢复出厂设置" class="headerlink" title="恢复出厂设置"></a>恢复出厂设置</h2><p>通过BootROM重置密码，并不代表交换机的配置被重置了，如果需要重置则需要执行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Quidway] reset save</span><br></pre></td></tr></table></figure><p>提示确认重置，输入<code>Y</code>确认</p><p>接着重启交换机，现在不需要拔电源了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Quidway] reboot</span><br></pre></td></tr></table></figure><p>提示需要保存配置之类的，不需要，输入 <code>N</code></p><p>再次提示，确认重启，输入 <code>Y</code>, 确认，</p><p>重启完成后，交换机就变成一个傻瓜交换机，功能同非网管交换机</p><h2 id="开启Web管理后台"><a href="#开启Web管理后台" class="headerlink" title="开启Web管理后台"></a>开启Web管理后台</h2><p>重要准备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir &#x2F;&#x2F;查看web.zip或web.7z的 文件名，后续的http server load中会用到</span><br></pre></td></tr></table></figure><p>开始配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sys </span><br><span class="line">int vlan 1   &#x2F;&#x2F;配置IP地址，以vlanif 1 为例</span><br><span class="line">ip addr 192.168.1.1 255.255.255.0 (举例) </span><br><span class="line">q </span><br><span class="line">http server load xxx.web.zip   &#x2F;&#x2F;加载web文件，见重要准备处显示的文件名.v200r005及以后的版本已集成，可跳过</span><br><span class="line">http secure-server enable      &#x2F;&#x2F;开启https,有的版本可以不输入此条</span><br><span class="line">http server enable             &#x2F;&#x2F;&#x2F;&#x2F;开启http</span><br><span class="line">aaa </span><br><span class="line">local-user admin password cipher xxx （改密码，可选） </span><br><span class="line">local-user admin service-type http telnet    &#x2F;&#x2F;设置权限</span><br><span class="line">local-user admin privilege level 15 </span><br><span class="line">q </span><br><span class="line">q </span><br><span class="line">save </span><br><span class="line">y</span><br></pre></td></tr></table></figure><p>IP和接口仅供参考，以实际需要为准</p><p>交换机接口默认属于vlan1</p><p>pc手动配好ip后，连接交换机的任意网口即可，打开。</p><p>此功能在S交换机中通用，如S2700,S3700,S5700,S6700,S7700,S9300,S9700</p><p>注意事项：</p><ol><li>部分v2r5的产品web包要加载一下，比如 5700-si</li><li>如查提示加密模式不对，无法改密码，请使用local-user xxxx password irr  xxxxxxxx来修改密码</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先要连上设备&quot;&gt;&lt;a href=&quot;#先要连上设备&quot; class=&quot;headerlink&quot; title=&quot;先要连上设备&quot;&gt;&lt;/a&gt;先要连上设备&lt;/h2&gt;&lt;h3 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;一台电脑（Windows系统，或是虚拟机都可以）&lt;/li&gt;
&lt;li&gt;一根console线（RJ45转R232串口的线）&lt;/li&gt;
&lt;li&gt;一个R232转USB线（如果电脑有串口可以忽略）&lt;/li&gt;
&lt;li&gt;USB 2.0 To COM Device驱动（如果电脑有串口可以忽略）&lt;/li&gt;
&lt;li&gt;超级终端（win7以上需要）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;连接&quot;&gt;&lt;a href=&quot;#连接&quot; class=&quot;headerlink&quot; title=&quot;连接&quot;&gt;&lt;/a&gt;连接&lt;/h3&gt;&lt;p&gt;把console线接到交换机的console口中，然后接串口转USB线，然后接电脑，如果是2016MBP，你还得转接Type-c。。。 holy shit！！！&lt;/p&gt;
&lt;p&gt;先装驱动：USB 2.0 To COM Device&lt;/p&gt;
&lt;p&gt;打开超级终端，没有说到的参数，随便写，&lt;/p&gt;
&lt;p&gt;串行选项中，需要配置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;端口，看设备管理里是COM几被连接上&lt;/li&gt;
&lt;li&gt;波特率：9600&lt;/li&gt;
&lt;li&gt;数据位：8&lt;/li&gt;
&lt;li&gt;奇偶校验：无&lt;/li&gt;
&lt;li&gt;停止位：1&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用vinyl-fs替换node中的fs来完成文件的批处理</title>
    <link href="https://koro.fun/2016/12/12/%E4%BD%BF%E7%94%A8node%E6%9D%A5%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86/"/>
    <id>https://koro.fun/2016/12/12/使用node来完成文件的批处理/</id>
    <published>2016-12-12T14:56:48.000Z</published>
    <updated>2017-01-03T06:47:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><p>这是这次博客迁移遇到的问题，hexo对markdown的管理是通过在文件顶部的yaml配置项来做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用node来完成文件的批处理</span><br><span class="line">date: 2016-12-12 22:56:48</span><br><span class="line">tags:</span><br><span class="line">description:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>我原来的文章当然没有这些东西，所以要给他加上，一个个加？可能加个把小时可以完成，但是这种重复劳动当然要交给代码来做</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>有哪些事情要做</p><ol><li>读取文件</li><li>获取所需信息: 文件名称，文件修改日期</li><li>创建插入字符串</li><li>插入</li><li>写出文件</li></ol><p>逻辑很简单，半个小时就能搞定。。。。吧</p><p>为了快速解决问题，我直接用Node来写，没怎么写过Node的代码，上来先看Node文档，</p><p>读取目录：<code>fs.readdir</code></p><p>读取文件，嗯，通过流的方式：<code>fs.createReadStream</code> </p><p>读取文件信息：<code>fs.stat</code></p><p>写入文件：<code>fs.createWriteStream</code></p><p>但是我是多层级的目录结构，还要我写递归来读取目录吗，记得原来做前端构建时有用过一个模块<code>glob</code>,可以识别 <code>src/**/*.js</code></p><p>替换好内容后，输出文件，<strong>问题来了，不能自动创建目录，这…</strong></p><p>再想想以前用gulp都是写入文件系统都是一个方法，指定好路径就可以，遂打开gulp的源码，原来如此</p><h3 id="vinyl-fs"><a href="#vinyl-fs" class="headerlink" title="vinyl-fs"></a>vinyl-fs</h3><p>其实gulp做了一套输入输出流的适配器接口及对象封装，并且单独抽离出来作为独立模块，也就是<a href="https://github.com/gulpjs/vinyl-fs" target="_blank" rel="noopener">vinyl-fs</a>, 通过它可以非常方便的对文件输入输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vfs.src([&#39;.&#x2F;js&#x2F;**&#x2F;*.js&#39;, &#39;!.&#x2F;js&#x2F;vendor&#x2F;*.js&#39;])</span><br><span class="line">  .pipe(through2.obj(function(file, enc, cb) &#123;</span><br><span class="line">  &#x2F;&#x2F; do anything you want!</span><br><span class="line">  &#125;))</span><br><span class="line">  .pipe(vfs.dest(&#39;.&#x2F;output&#39;));</span><br></pre></td></tr></table></figure><p>不过需要注意的是through2在处理流回调中的file是vinyl对象，而不是普通的Buffer对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var jsFile &#x3D; new Vinyl(&#123;</span><br><span class="line">  cwd: &#39;&#x2F;&#39;,</span><br><span class="line">  base: &#39;&#x2F;test&#x2F;&#39;,</span><br><span class="line">  path: &#39;&#x2F;test&#x2F;file.js&#39;,</span><br><span class="line">  contents: new Buffer(&#39;var x &#x3D; 123&#39;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>vinyl.contents</code>才是文件内容的buffer对象</p><p>终于，在vinyl-fs的帮助下，我花了5个小时完成了这个文章迁移工作，嗯，还行</p>]]></content>
    
    <summary type="html">
    
      其实gulp做了一套输入输出流的适配器接口及对象封装，并且单独抽离出来作为独立模块，也就是[vinyl-fs](https://github.com/gulpjs/vinyl-fs), 通过它可以非常方便的对文件输入输出
    
    </summary>
    
    
      <category term="nodejs" scheme="https://koro.fun/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中的数组-Array</title>
    <link href="https://koro.fun/2016/11/11/Javascript/Javascript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84-Array/"/>
    <id>https://koro.fun/2016/11/11/Javascript/Javascript中的数组-Array/</id>
    <published>2016-11-11T06:23:01.000Z</published>
    <updated>2017-03-19T08:57:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要供平时健忘症发作的时候查阅, 详细的可以参考这个<a href="http://javascript.ruanyifeng.com/stdlib/array.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/stdlib/array.html</a></p></blockquote><h2 id="操作当前数组"><a href="#操作当前数组" class="headerlink" title="操作当前数组"></a>操作当前数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pop()&#x2F;&#x2F; 从尾部去掉</span><br><span class="line">push()&#x2F;&#x2F; 从尾部加入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unshift(insert1,insert2…insertN)     &#x2F;&#x2F;从头部加入，不支持ie</span><br><span class="line">shift()         &#x2F;&#x2F;从头部删除</span><br><span class="line"></span><br><span class="line">sort(sortby)&#x2F;&#x2F; sortby非必填</span><br><span class="line"></span><br><span class="line">reverse()     &#x2F;&#x2F;反转数组</span><br><span class="line"></span><br><span class="line">splice(index,howmany,insert1,insert2…insertN)</span><br><span class="line">&#x2F;&#x2F; insert非必填</span><br><span class="line">&#x2F;&#x2F; 返回值是切割出来新的数组，</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="返回新数组"><a href="#返回新数组" class="headerlink" title="返回新数组"></a>返回新数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">concat(arr1,arr2…..arrN);</span><br><span class="line"></span><br><span class="line">slice(start,end)&#x2F;&#x2F; start参数可以为负，即重数组尾部开始, end可以为任何</span><br></pre></td></tr></table></figure><h2 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h2><p>join(分隔符)</p><h2 id="继承Object的方法"><a href="#继承Object的方法" class="headerlink" title="继承Object的方法"></a>继承Object的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toLocaleString()</span><br><span class="line">toString()</span><br><span class="line">valueOf()</span><br><span class="line">toSource() &#x2F;&#x2F;仅Gecko内核支持</span><br></pre></td></tr></table></figure><h2 id="ES5新特性"><a href="#ES5新特性" class="headerlink" title="ES5新特性"></a>ES5新特性</h2><h3 id="没有返回值"><a href="#没有返回值" class="headerlink" title="没有返回值"></a>没有返回值</h3><ul><li>forEach    // 枚举数组，没有返回值，这个不用举例子了</li></ul><h3 id="返回索引值"><a href="#返回索引值" class="headerlink" title="返回索引值"></a>返回索引值</h3><ul><li>indexOf    </li><li>lastIndexOf: 过程和indexOf不一样，从后往前计算，结果是一样的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];</span><br><span class="line">arr.indexOf(&#39;c&#39;); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><h3 id="返回Boolean值"><a href="#返回Boolean值" class="headerlink" title="返回Boolean值"></a>返回Boolean值</h3><ul><li>some    // 任意一项为true，即返回true</li><li>every    // 所有项都为true，才返回true</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; some方法 判断数组内的是否存在一个大于等于3的元素</span><br><span class="line">var arr &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">var ret &#x3D; arr.some(function (elem, index, arr) &#123;</span><br><span class="line">  return elem &gt;&#x3D; 3;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(ret); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; every方法 比较两个数组内容是否相同</span><br><span class="line">var arr1 &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">var ret &#x3D; arr.length &#x3D;&#x3D;&#x3D; arr1.length &amp;&amp; </span><br><span class="line">arr.every(function (elem, index, arr) &#123;</span><br><span class="line">  return elem &#x3D;&#x3D;&#x3D; arr1[index];</span><br><span class="line">&#125;);</span><br><span class="line">console.log(ret); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h3 id="返回一个新的数组"><a href="#返回一个新的数组" class="headerlink" title="返回一个新的数组"></a>返回一个新的数组</h3><ul><li>reduce // 选代数组所有项，然后构建一个最终返回的值</li><li>reduceRight</li></ul><p>reduce方法接收两个参数，第一个是回调函数，第二个参数则是指定返回的第一个prev是什么值</p><p>例如：获取一个Number数组的和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1,3,5,7].reduce(function(prev,current) &#123;</span><br><span class="line">return prev + current;</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回值为： 16</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(function(prev,cur,index,array)&#123;</span><br><span class="line">        return prev+cur;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ul><li>filter: 过滤符合回调中的条件的数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].filter(function (elem) &#123;</span><br><span class="line">  return (elem &gt; 3);</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; [4, 5]</span><br></pre></td></tr></table></figure><ul><li>map: 对数组的所有成员依次执行回调函数，根据函数结果返回一个新数组。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].map(function(elem, index, arr) &#123;</span><br><span class="line">  return elem * index;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; [0, 2, 6]</span><br></pre></td></tr></table></figure><h2 id="ES2015新特性"><a href="#ES2015新特性" class="headerlink" title="ES2015新特性"></a>ES2015新特性</h2><p>// TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要供平时健忘症发作的时候查阅, 详细的可以参考这个&lt;a href=&quot;http://javascript.ruanyifeng.com/stdlib/array.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://javascript.ruanyifeng.com/stdlib/array.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;操作当前数组&quot;&gt;&lt;a href=&quot;#操作当前数组&quot; class=&quot;headerlink&quot; title=&quot;操作当前数组&quot;&gt;&lt;/a&gt;操作当前数组&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pop()		&amp;#x2F;&amp;#x2F; 从尾部去掉&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;push()		&amp;#x2F;&amp;#x2F; 从尾部加入&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unshift(insert1,insert2…insertN)     &amp;#x2F;&amp;#x2F;从头部加入，不支持ie&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;shift()         &amp;#x2F;&amp;#x2F;从头部删除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sort(sortby)		&amp;#x2F;&amp;#x2F; sortby非必填&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reverse()     &amp;#x2F;&amp;#x2F;反转数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;splice(index,howmany,insert1,insert2…insertN)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; insert非必填&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 返回值是切割出来新的数组，&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flex布局学习笔记</title>
    <link href="https://koro.fun/2016/11/11/Flex%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://koro.fun/2016/11/11/Flex布局学习笔记/</id>
    <published>2016-11-11T06:22:35.000Z</published>
    <updated>2017-02-17T08:57:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之所以有本文的原因是，在某些网络环境下，阮一峰的博客有时会打不开（或者很卡），所以把图片内容去掉后复制过来，方便自己查阅</p><p>原文链接：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex布局教程：语法篇</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;item&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="容器样式-box"><a href="#容器样式-box" class="headerlink" title="容器样式(.box)"></a>容器样式(.box)</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><ul><li>flex-direction: row | row-reverse | column | column-reverse;</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>row（默认值）：</td><td>主轴为水平方向，起点在左端。</td></tr><tr><td>row-reverse：</td><td>主轴为水平方向，起点在右端。</td></tr><tr><td>column：</td><td>主轴为垂直方向，起点在上沿。</td></tr><tr><td>column-reverse：</td><td>主轴为垂直方向，起点在下沿。</td></tr></tbody></table><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><ul><li>flex-wrap: nowrap | wrap | wrap-reverse;</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>nowrap（默认）：</td><td>不换行。</td></tr><tr><td>wrap：</td><td>换行，第一行在上方。</td></tr><tr><td>wrap-reverse：</td><td>换行，第一行在下方。</td></tr></tbody></table><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><ul><li>flex-flow: <code>&lt;flex-direction&gt;</code> || <code>&lt;flex-wrap&gt;</code>;</li></ul><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p><a id="more"></a><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><ul><li>justify-content: flex-start | flex-end | center | space-between | space-around;</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>flex-start（默认值）：</td><td>左对齐</td></tr><tr><td>flex-end：</td><td>右对齐</td></tr><tr><td>center：</td><td>居中</td></tr><tr><td>space-between：</td><td>两端对齐，项目之间的间隔都相等。</td></tr><tr><td>space-around：</td><td>每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</td></tr></tbody></table><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><ul><li>align-items: flex-start | flex-end | center | baseline | stretch;</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>flex-start：</td><td>交叉轴的起点对齐。</td></tr><tr><td>flex-end：</td><td>交叉轴的终点对齐。</td></tr><tr><td>center：</td><td>交叉轴的中点对齐。</td></tr><tr><td>baseline:</td><td>项目的第一行文字的基线对齐。</td></tr><tr><td>stretch（默认值）：</td><td>如果项目未设置高度或设为auto，将占满整个容器的高度。</td></tr></tbody></table><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><ul><li>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>flex-start：</td><td>与交叉轴的起点对齐。</td></tr><tr><td>flex-end：</td><td>与交叉轴的终点对齐。</td></tr><tr><td>center：</td><td>与交叉轴的中点对齐。</td></tr><tr><td>space-between：</td><td>与交叉轴两端对齐，轴线之间的间隔平均分布。</td></tr><tr><td>space-around：</td><td>每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</td></tr><tr><td>stretch（默认值）：</td><td>轴线占满整个交叉轴。</td></tr></tbody></table><h2 id="项目样式-item"><a href="#项目样式-item" class="headerlink" title="项目样式(.item)"></a>项目样式(.item)</h2><h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><h3 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><ul><li>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。</li><li>如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</li></ul><h3 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。0不缩小</p><h3 id="flex属性（一般设置这个就可以）"><a href="#flex属性（一般设置这个就可以）" class="headerlink" title="flex属性（一般设置这个就可以）"></a>flex属性（一般设置这个就可以）</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h3><p>align-self属性允许<strong>单个项目有与其他项目不一样</strong>的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之所以有本文的原因是，在某些网络环境下，阮一峰的博客有时会打不开（或者很卡），所以把图片内容去掉后复制过来，方便自己查阅&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flex布局教程：语法篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div class&amp;#x3D;&amp;quot;box&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;div class&amp;#x3D;&amp;quot;item&amp;quot;&amp;gt;&amp;lt;&amp;#x2F;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;div class&amp;#x3D;&amp;quot;item&amp;quot;&amp;gt;&amp;lt;&amp;#x2F;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;div class&amp;#x3D;&amp;quot;item&amp;quot;&amp;gt;&amp;lt;&amp;#x2F;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;#x2F;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;容器样式-box&quot;&gt;&lt;a href=&quot;#容器样式-box&quot; class=&quot;headerlink&quot; title=&quot;容器样式(.box)&quot;&gt;&lt;/a&gt;容器样式(.box)&lt;/h2&gt;&lt;h3 id=&quot;flex-direction&quot;&gt;&lt;a href=&quot;#flex-direction&quot; class=&quot;headerlink&quot; title=&quot;flex-direction&quot;&gt;&lt;/a&gt;flex-direction&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;flex-direction: row | row-reverse | column | column-reverse;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;row（默认值）：&lt;/td&gt;
&lt;td&gt;主轴为水平方向，起点在左端。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;row-reverse：&lt;/td&gt;
&lt;td&gt;主轴为水平方向，起点在右端。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;column：&lt;/td&gt;
&lt;td&gt;主轴为垂直方向，起点在上沿。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;column-reverse：&lt;/td&gt;
&lt;td&gt;主轴为垂直方向，起点在下沿。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;flex-wrap&quot;&gt;&lt;a href=&quot;#flex-wrap&quot; class=&quot;headerlink&quot; title=&quot;flex-wrap&quot;&gt;&lt;/a&gt;flex-wrap&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;flex-wrap: nowrap | wrap | wrap-reverse;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;nowrap（默认）：&lt;/td&gt;
&lt;td&gt;不换行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wrap：&lt;/td&gt;
&lt;td&gt;换行，第一行在上方。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wrap-reverse：&lt;/td&gt;
&lt;td&gt;换行，第一行在下方。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;flex-flow&quot;&gt;&lt;a href=&quot;#flex-flow&quot; class=&quot;headerlink&quot; title=&quot;flex-flow&quot;&gt;&lt;/a&gt;flex-flow&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;flex-flow: &lt;code&gt;&amp;lt;flex-direction&amp;gt;&lt;/code&gt; || &lt;code&gt;&amp;lt;flex-wrap&amp;gt;&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://koro.fun/tags/CSS/"/>
    
      <category term="Flex" scheme="https://koro.fun/tags/Flex/"/>
    
  </entry>
  
</feed>
